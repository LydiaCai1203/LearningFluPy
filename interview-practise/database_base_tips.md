## REVIEW OF DATABASE（阿菜2019年自制面经）

------------------
### 1. 数据库的四个范式
    1. 属性（字段）是最小的单位不可以再分。
    2. 在满足第一范式的前提下，每个非主属性都完全依赖于主键。
    3. 在满足第二范式的前提下，每个非主属性都不依赖于其它的非主属性。
    4. 在满足第三范式的前提下，属性之间不能有非平凡且非函数依赖的多值依赖。

------------------
### 2. 数据库的事务
    1. 事务是用户定义的一个数据库操作的原子序列，要么全做，要么全都不做
    2. 事务的四大特性：原子性、隔离性、一致性、持续性

------------------
### 3. 数据库事务的几种隔离级别
    1. Read uncommitted 
    所有事务都可以看到其它未提交事务的执行结果，读取到未提交的数据，也称之为脏读。
    
    2. Read committed 这不是MySQL默认的隔离级别
    一个事务只能看见已经提交事务所做的改变，这种隔离级别支持所谓的不可重复读，因为同一事务的其它实例在该实例的处理期间可能会有新的commit,所以同一个select语句都可能返回不同的结果。
    
    3. Repeatable read 这是MySQL默认的隔离级别
    它确保同一个事务的多个实例在并发地读取数据时，会看到同样的数据行，但是会导致另一个问题也就是'幻读'。
    
    4. Serializable 这是最高的隔离级别
    它通过强制事务排序，使之不可能互相发生冲突，也就是说，它是在每个读的数据行上加上共享锁，但是这样做会导致的直接问题就是，可能导致大量的超时现象和锁竞争现象。

------------------
### 4. 数据库索引的实现有哪些数据结构
    1. 索引是帮助MySQL高效获取数据的数据结构。
    2. 常见的索引有两种结构：Hash索引和B+Tree索引，如果我们使用的是InnoDB,默认的是B+Tree（这里有可能会问一些和存储引擎相关的问题）

------------------
### 5. 你知道为什么采用B+Tree吗？和Hash索引比较起来有什么优缺点吗
    1. Hash索引的底层是哈希表，哈希表是一种以key-value存储数据的结构，所以多个数据在存储关系上是完全没有任何的顺序关系的。对于区间查询是无法直接通过索引查询的，就需要进行全表扫描。所以哈希索引只适用于等值查询的场景。
    2. B+Tree是一种多路平衡查找树，所以他的节点是天然有序的，左子节点小于父节点，父节点小于右子节点，对于范围查询的时候不需要做全表扫描。
    3. Hash索引没有办法利用索引完成排序。
    4. Hash索引不支持多列联合索引的最左匹配排序。
    5. 如果有大量重复键值的情况下，Hash索引的效率会很低，因为存在Hash碰撞的问题。

-----------------
### 6. 索引的缺点是什么
    1. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
    2. 索引需要占用物理空间，除了数据表占用数据空间以外，每一个索引都要占据一定的物理空间，
    3. 对表中的数据进行增加、删除和修改的时候，索引也需要动态维护。

-----------------
### 7. 说一下redis和MongoDB的区别
    1. 性能
        Redis的性能要优于MongoDB 
    2. 存储的数据结构
        Redis的数据结构有Set、String、List、Dict、等多种数据结构。MongoDB里面每个collections都是由一个个dict组成的。
    3. 存储空间
        MongoDB所有的数据实际上都是放在硬盘上面的，所有操作的数据都是映射到内存上，然后再进行操作的。
        Redis所有的数据都是放在内存上的，如果断电的话，数据就会消失，所以需要做数据持久化。
        MySQL所有的数据都是放在硬盘上面的，要使用的时候才会交换到内存，能够处理远超过内存总量的数据。
    4. 还有可说的，暂时不写 因为说出什么就是引导面试官往什么方向上去问。

-----------------
### 8. redis为什么没有索引？
    这道题我的回答不好 首先是因为上一道在Redis 和 MongoDB的区别里面，我说了Redis是没有索引的，但是MongoDB里面有。Redis没有索引我说的也是，因为建立索引的目的是为了达到更高效的搜索，Redis本身的数据就是存在内存里面的，所以没有必要建索引了。但是我总觉得面试官是希望我从建立索引的结构层面来解释。所以下一步我要开始全面复习MySQL了。ß

-----------------
### 9. 说一下乐观锁和悲观锁的区别
    乐观锁：
        在关系型数据库里面，乐观并发控制是一种并发控制的方法，它假设用户并发的事务在处理的时候不会相互影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务都会检查在该事务读取数据以后，有没有其它事务又修改了该数据。如果其它事务有对数据进行更新的话，正在提交的事务就会进行回滚。适合用于度多写少的情况。
    悲观锁：
        在关系型数据库里面 ，悲观并发控制是一种并发控制的方法。它可以阻止一个事务以影响其它用户的方式修改数据，如果一个事务执行的操作读某行数据应用了锁，只有当这个事务把锁释放，其它的事务才能修改数据。

-----------------
### 10. 能说一下为什么B+树这样的数据结构可以拿来作为索引呢
[平衡树](https://github.com/AaronXYZ/PersonalBlog/issues/20)

[平衡树可视化构建过程](https://www.cs.usfca.edu/~galles/visualization/AVLtree.html)

[B-Tree和B+Tree比较通俗的解释](https://blog.csdn.net/yin767833376/article/details/81511377)

[数据库索引](https://www.kancloud.cn/kancloud/theory-of-mysql-index/41856)

        1. 首先索引里面存的指针存的是数据库里面数据的物理地址 索引里面还有一个索引键值
        2. 真实世界的索引并没有使用二叉树或者是红黑树的实现 大部分都是B-Tree或者是B+Tree的实现
#### B-Tree
    假如有一本英文字典，单词+详细解释组成了一条记录，现在需要索引单词，就会以单词为key, 单词+详细解释为data。B-Tree就是以这样一个二元组{key, data}来定义一条记录的。如果一个节点有三条记录，那么会有对应的四个指针，用以指向下一个结点。B-Tree是有序而且平衡的，所有的叶子节点都在同一层。

+ 搜索：首先从跟节点进行查找，找到了就返回对应节点的data。否则对相应区间指向的指针  

#### B+Tree
    1. B+Tree非叶子节点都只有key,没有data。
    2. 所有的叶子节点之间都有一个链指针。
    3. 数据记录都存放在叶子节点中。

#### 评判标准

    一般来说，索引本身也很大，是不可能全部存在内存中的，因此索引往往以索引文件的形式存储在磁盘上面。这样在索引查找的过程中就要产生I/O磁盘消耗，相对于内存的存取，I/O存取的消耗要高几个数量级。所以，评价一个索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的渐进复杂度。

+ 主存存取原理

    目前计算计算机使用的主存都是随机读写存储器，主存是一系列的存储单元组成的矩阵，每个存储单元存储固定大小的数据，每个存储单元都有唯一的地址，这里是一个二维地址。主存的存取过程如下：当系统需要读取主存的时候，会将地址信号放到地址总线上传给主存，主存读到信号以后，解析信号并且定位到指定的存储单元，然后将读到的数据放到地址总线上面，供其它的部件读取。
    <br>
    sum: 所以主存存取的时间消耗，只和存取次数有关系，和要存取的数据之间的距离并没有关系。


+ 磁盘存取原理

    磁盘I/O存在机械运动耗费，所以磁盘I/O的消耗是巨大的，索引一般又是以磁盘文件的形式存储在磁盘上的。
    一个磁盘是以几个同轴且大小相等的圆片组成的，每个磁盘都必须同步转动，在磁盘的一侧有磁头支架，磁头支架固定了一组磁头，每一个磁头都负责存取一个磁盘的内容。磁头是不能转动的，但是可以沿着磁盘的半径方向运动。从正下方看，所有的磁头在每一个时刻都应该必须是重叠的。目前已经有多磁头独立的技术了。

    每一个扇区是磁盘存取的最小单元。当需要进行磁盘读取的时候，系统会将数据逻辑地址传给磁盘，磁盘的控制电路会将逻辑地址变成物理地址，寻找对应的磁道时间叫做寻道时间，寻找对应的扇区的时间叫做旋转时间。
    <br>
    sum: 所以磁盘存取的时间消耗和寻道时间以及旋转时间有关系。


+ 局部性原理和磁盘预读

    磁盘每次读取都会进行预读，即使只需要一个字节，磁盘也会从这个位置开始向后读取一定的长度放入内存。由于磁盘顺序读取的时候效率高，不需要花费寻道时间，只需要花费少量的旋转时间，预读的长度一般为页的整数倍。页是计算机管理存储器的逻辑块，页的大小通常是4K，主存和磁盘都是以页为单位进行数据交换的。当要读取的数据不在主存中的时候，会发起一个缺页信号，然后系统就会和磁盘发起读盘信号。磁盘会找到数据起点，然后将之后的一页或者几页，读取出来存进内存里面。


#### 进入正题 为什么要使用B-Tree/B+Tree来实现索引
    
    1. 根据B-Tree的定义，检索一次至多会访问h个节点，数据库的设计者将一个节点设置为磁盘中的一个页，这样每个节点需要一次I/O就可以完全载入。所以每次在新建一个节点的时候，就会直接申请一个页的空间。由于根节点常驻内存，所以在B-Tree中检索一次最多需要h-1次I/O.

    2. 红黑树的深度要深，且逻辑上很近的父子节点物理上可能隔很远，无法利用局部性。红黑树的效率要差很多。

    3. B+Tree因为去掉了内节点的data部分，因此可以拥有更大的出度，所以B+Tree其实更加适合外存索引。


#### 不同的数据库引擎 与 不同的索引实现

+ MyISAM(B+Tree)
[myisam]()

+ InnoDB



### ★★☆ 手写 SQL 语句，特别是连接查询与分组查询。
### ★★☆ 连接查询与子查询的比较。
### ★★☆ drop、delete、truncate 比较。
### ★★☆ 视图的作用，以及何时能更新视图。
### ★☆☆ 理解存储过程、触发器等作用。

### ★★★ ACID 的作用以及实现原理。
### ★★★ 四大隔离级别，以及不可重复读和幻影读的出现原因。
### ★★☆ 封锁的类型以及粒度，两段锁协议，隐式和显示锁定。
### ★★★ 乐观锁与悲观锁。
### ★★★ MVCC 原理，当前读以及快照读，Next-Key Locks 解决幻影读。
### ★★☆ 范式理论。
### ★★★ SQL 与 NoSQL 的比较。

### ★★★ B+ Tree 原理，与其它查找树的比较。
### ★★★ MySQL 索引以及优化。
### ★★★ 查询优化。
### ★★★ InnoDB 与 MyISAM 比较。
### ★★☆ 水平切分与垂直切分。
### ★★☆ 主从复制原理、作用、实现。
### ★☆☆ redo、undo、binlog 日志的作用。

### ★★☆ 字典和跳跃表原理分析。
### ★★★ 使用场景。
### ★★★ 与 Memchached 的比较。
### ★☆☆ 数据淘汰机制。
### ★★☆ RDB 和 AOF 持久化机制。
### ★★☆ 事件驱动模型。
### ★☆☆ 主从复制原理。
### ★★★ 集群与分布式。
### ★★☆ 事务原理。
### ★★★ 线程安全问题。