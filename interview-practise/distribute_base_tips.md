## 分布式相关基础知识

### 1. 架构演变历程

**1. 单体应用架构**

```markdown
概念：所有的功能都在一个应用里。
好处是：开发、测试、部署方便、本地调用对于远程调用性能较好。
坏处是：
    a. 系统耦合性能高，随着代码越多，代码质量和开发效率都会变低。
    b. 修改的地方可能牵一发动全身。某个模块出问题了，可能导致整个应用都要回滚。
    c. 语言单一，不能根据场景选择更加合适的语言。
    d. 系统整体的可用性不高。系统不易于扩展部署。
```

**2. 微服务架构**

```markdown
概念：根据不同的业务拆分出不同的服务，每个服务独立部署，代码进行了物理隔离。数据库可能也拆分出来，每个服务维护的是自己的数据库。数据库之间的数据通过接口传递。
好处：
    a. 系统的耦合度降低
    b. 系统整体可靠性变高
    c. 技术选型丰富，不同的服务可以利用不同的技术或语言实现
    d. 可以根据服务来进行扩展部署
坏处：
    a. 引入分布式链路追踪服务来定位问题
    b. 引入 ELK 方便日志的查看，分析问题
    c. 为了可以动态扩容，服务需要自动注册和自动被发现，需要一个注册中心
    d. 网络之间的调用较为不可靠，调用需要添加重试机制，限流机制，熔断措施等等
    e. 特殊的时候让出硬件资源给核心功能，需要有降级策略
    f. 每个服务都需要配置，因此还需要一个配置中心来做统一管理。
    g. 整体的监控
    h. devops、容器等等
```

**3. SOA 和 微服务**

```markdown
SOA(Service-Oriented Architecture) 面向服务的架构。而说到 SOA 就离不开 ESB(Enterprise Service Bus) SOA 和 微服务 一样都是面向服务的。
```

![](/Users/cqj/project/private/leetcode-practice/statics/soa_architecture.jpg)

```markdown
SOA：
SOA 架构通过企业服务总线进行交互，即中心化，需要按照总线的标准进行开发改造。

微服务：
则是去中心化的。SOA 更加注重企业资源的重复利用，把企业的各个应用通过 ESB 进行整合。微服务注重的是应用级别的服务划分，使得应用内服务边界清晰，易扩展。

当然也可以是 SOA 内包含 微服务 的这样一个总架构。
```

**4. 分布式和集群**

```markdown
分布式：
分布式可以认为是通过网络连接多个组建而形成的系统。前后端分离其实就算分布式。我们常提到的分布式是指不同的组件通过协作构成的系统。

集群：
通常指的是同一个组件多个实例而构成逻辑上的整体。
```

### 2. 分布式事务的解决方案有哪些？

场景：

简单的电商平台有库存微服务、订单微服务、购物微服务。用户通过购物微服务进行下单，然后通过库存微服务进行库存扣减，再通过订单微服务插入订单记录。其中库存微服务设计库存库，订单微服务设计订单库。**用户下订单以后，肯定要保证三个操作都能成功执行。这就是针对多数据源提出的分布式事务机制。**

#### 2.1 分布式事务模型

+ 事务参与者：每个数据库就是一个事务参与者

+ 事务协调者：访问多个数据源的服务程序，比如购物微服务就是事务协调者

+ 资源管理器(resource manager)：与事务参与者同义

+ 事务管理器(transaction manager)：与事务协调者同义

#### 2.2 两阶段提交(2PC) 和 三阶段提交(3PC) 方案

```markdown
二阶段提交：
1) 准备阶段
1. 事务管理器 向 资源管理器 发送准备消息
2. 资源管理器各自执行本地事务到待提交阶段
3. 资源管理器 向 事务管理器 发送响应，表示已经准备好，允许提交全局事务。（如果表示没准备好，可能是因为无法拿到所需的本地资源，因为被其他的本地事务锁住了，或者超时）
2) 提交阶段
1. 各个资源管理器返回响应都是 yes，则事务管理器向所有的资源管理器发起事务提交操作
2. 各个资源管理器收到以后执行本地事务提交操作，并向事务管理器发送 ACK
3. 如果有任何一个资源管理器回复的是 no 或者 超时，事务管理器发送回滚操作
所有的资源管理器收到以后各自回滚本地事务，然后向协调者发送 ACK

缺点：
1. 单点故障，尤其是提交阶段，如果协调者发生故障，所有的参与者都会处于锁定资源的状态，无法下行。如果协调者宕机了，即使再重新选举一个，它也不知道这个事务是否已经被提交了。
2. 性能差，准备阶段所有参与者都会锁住资源，别的服务只能阻塞。
3. 数据不一致的问题，在提交阶段，只有一部分的参与者收到了 commit 消息，那么只有一部分参与者提交成功。另一部分参与者还在阻塞状态。这时候分布式系统就会出现数据不一致的情况了。
```

**可以简单地把 prepare()、commit()、rollback() 这三个接口理解为 XA 协议。XA 协议是 X/Open 提出的分布式事务处理标准。许多主流数据库都实现了 XA 协议，因此都能被用于实现 2PC 事务模型**。

```markdown
三阶段提交：
三阶段提交分别是 询问阶段、准备阶段、提交或回滚阶段。3PC 利用超时机制解决了 2PC 的同步阻塞问题，避免了资源被永久的锁定，但是同样无法应对类似宕机的问题，只是出现多数据源中数据不一致的问题的概率更加小罢了。
```

#### 2.4 TCC 方案

```markdown
TCC(Try、Confirm、Cancel)，是一种解决多个微服务之间的分布式事务问题的方案。本质是一个应用层面的 2PC, 同样可以分为两个阶段。是由支付宝团队提出的，被广泛地应用于金融系统中。比如说我们买币，部分金额会先被冻结，由此猜想，这个就是 TCC 的第一个阶段。

1. 准备阶段
1) 协调者调用所有的微服务提供的 try 接口，将整个全局事务涉及的资源锁定住，锁定成功的话，try 接口向协调者返回 yes。
2. 提交阶段
1) 若所有的服务的 try 接口都在阶段一返回 yes，则协调者会调用所有服务的 confirm 接口，然后各个服务进行事务提交
2) 如果有任何一个服务的 try 接口在阶段一返回 no 或者 超时，则协调者就调用所有服务的 cancel 接口

优点：
1. 解决了某个参与者宕机以后，再次重启，无法保证之前没执行完的分布式事务执行完。TCC 框架需要记录一些分布式事务的活动日志的，保存分布式事务运行的各个阶段和状态。
2. 万一某个参与者的 cancel 或 confirm 接口逻辑执行失败了，后续该怎么办的问题。TCC 框架会一直进行重试，直到 confirm 或 cancel 接口都返回 ACK。
3. 另外在不断重试的过程中，还需要注意接口的幂等性。保证每个参与者只进行一次 confirm 或 cancel。
```

#### 2.5 事务状态表方案

```markdown
假设要在一个分布式事务中实现调用 库存服务 扣减库存，调用 订单服务 生成订单。这时就可以维护一张如下的事务状态表。初始状态为1，然后每成功调用一个服务就更新一次状态，最后所有的服务都调用成功，状态更新到3。哪一步没成功就一直重试，如果事务状态置为 error，告警，人工介入干预。每个服务的接口都需要根据全局的分布式 ID 做幂等。
```

| 分布式事务ID         | 事务内容                | 事务状态                          |
| --------------- | ------------------- | ----------------------------- |
| global_trx_id_1 | 操作1:扣减库存; 操作2: 生成订单 | 状态1:初始；状态2:操作1成功；状态3:操作1,2均成功 |

#### 2.6 基于消息中间件的最终一致性事务方案

*以上方案的本质都遵守 XA 协议的思想，都是协调者协调各个参与者的事务的进度，使其共同提交或者回滚。但是全局事务方案操作繁琐，时间跨度大，在全局事务期间，拍他锁会锁住所有的相关资源，使得整个分布式系统的全局并发读不会太高，很难满足电商等高并发长巾对事务吞吐量的要求。因此互联网服务提供上探索出了很多其他的方案，就是利用消息中间件实现的最终一致性。*

![](/Users/cqj/project/private/leetcode-practice/statics/mq_lock.jpg)

```markdown
1. 在 order-service 中（在一个服务中的步骤要保证原子性）
1）t_order 表中添加订单记录
2）在 t_local_msg 中添加对应的扣减库存消息

2. 在 repo-service 中（在一个服务中的步骤要保证原子性）
1）检查本次扣减库存操作是否已经执行过
2) 如果本次扣减操作没有执行过，执行扣减库存
3) 写判重表
4) 向 mq 返回消息完成的 ACK

3. order-service 有一个后台任务，将 t_local_msg 里的消息源源不断取出来发给 mq。得到 mq 的 ACK 以后，在本地的 t_local_msg 表中删除这条记录。另外保证消息发送到 mq 里面是有序的就行。


4. repo-service 拿到 repo_deduction_msg 消息以后，repo-service 成功处理完会向 mq 响应 ACK，mq 收到这个 ACK 才会认为 repo-service 成功处理了。否则就重复推送。repo-service 要做幂等性处理。可能是在 repo-service 中维护了一张判重表，成功处理过的消息 ID 就不再处理了。
```

**优点：**

1. 不重不漏

2. 严格实现了 repo-service 和 order-service 之间的一致性

3. 如果多次重试失败就要进行返回失败，然后回滚，不然订单下了，但是冻结却一直没成功，一直在重试，就出问题了。反方向思考也是一样的。

#### 2.7 Seata in AT mode 的实现

[自己看吧](https://mp.weixin.qq.com/s/ujRRtdLOeKEHsHrtDRNXGA)

### 2. 分布式 ID 的算法

```markdown
分布式 ID 首先要满足 全局唯一性、趋势递增、单调递增、信息安全 这几种要求。

**UUID(Universally Unique Identifier) **
概念：标准形式包含 32 个 16 进制的数字，以连字号分为 5 段。
优点：1.性能非常高 2.本地生成没有网络消耗
缺点：1.不易于存储 2.信息不安全 3.如果把 UUID 作为主键的话，非常不适用。官方文档上明确定义越短越好，36 个字符的 UUID 不符合要求。

****
```

### 3. RPC 是什么
