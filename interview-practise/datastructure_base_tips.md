## REVIEW OF DATASTRUCTURE（阿菜2019年自制面经）

##### 所以数据结构与算法和设计模式有关的面试题我全都放在这里了
[笨方法学算法](https://python-data-structures-and-algorithms.readthedocs.io/zh/latest/)

------------------
### 1. 几大排序算法

#### 排序算法的执行效率从：
    1. 时间复杂度（最好情况下的时间复杂度，最坏情况下的时间复杂度，平均时间复杂度）
    2. 时间复杂度的系数、常数、低阶 这些都是可以忽略掉的(N特别打的前提下)
    3. 求的其实是比较次数和交换以及移动的次数
    4. 排序算法的内存消耗
    5. 排序算法的稳定性

##### 因为实际开发中，要排序的往往是一组对象，排序的往往是对象的某个key进行排序，但是对象还有其它的属性值，稳定排序算法可以保证对象在排序的时候，key相同的对象之间的相对顺序是正确的。

#### 冒泡排序：
    空间复杂度O(1)       # 是一个原地排序算法
    稳定
    最好的时间复杂度O(N)  # 只需要循环一次，但是元素需要交换N-1次，(N-1)+1=N 
    最坏的时间复杂度O(N)  # 最坏的情况就是循环N-1次，[1+2+3+...+(N-1)] + (N-1) 约等于 N**2
    平均的时间复杂度O(N)  # O(N**2)

#### 插入排序
    首先有一个有序数组，将要插入的数依此和这个有序数组里面的每一个数做对比，然后比较大小进行插入。
    空间复杂度O(1) 
    稳定
    最好的时间复杂度O(N)
    最坏的时间复杂度O(N**2)
    平均的时间复杂度O(N**2)

#### 选择排序
    每次都会从无序数组中找出最小的，然后放在有序数组的末尾
    空间复杂度O(1)
    不稳定
    最好的时间复杂度O(N**2)
    最坏的时间复杂度O(N**2)
    平均的时间复杂度O(N**2)

**以上三种排序算法适合小规模的排序**

#### 归并排序
    首先有一堆数组，然后一分为二，再分别将两组一分为二，一直分，直到每个小组都只有两个元素，然后再将小组进行归并，
    合成一个有序的长数组。
    稳定
    最好的时间复杂度O(NlogN)
    最坏的时间复杂度O(NlogN)
    平均的时间复杂度O(NlogN)

#### 快速排序
[理解哨兵的算法看这里，这个比较好懂](https://blog.csdn.net/kmyhy/article/details/82991482)
    
    首先有一堆数组，然后N/2取一个值当pivot, 将所有比pivot小的都排到左边，所有比pivot大的都排到右边去，递归
    空间复杂度 O(1)
    不稳定
    最好的时间复杂度O(NlogN)
    最坏的时间复杂度O(N**2)
    平均的时间复杂度O(NlogN)
    
------------------
### 2. 发生散列冲突时的几种解决方法
    1. 开放寻址法
        a. 线性探测(step=1,2,3...)
        b. 二次探测(step=1, 2**2, 3**2...)
        c. 双重散列(一组hash函数进行散列)
    2. 链表法
        a. 一个value一个slot,一个slot里面有一个链表，插入的时间复杂度是O(1),查找和删除的时间复杂度和链表的长度成正比

------------------
### 3. B树、B+树、B-树的区别是什么
    pass 

------------------
### 4. 你知道大顶堆和小顶堆吗
    pass

