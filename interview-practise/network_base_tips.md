## 计算机网络基础
[直接看大神的github](https://github.com/justStarNew/Backend-Interview-Guide/blob/master/doc/%E4%B8%80%E6%96%87%E5%B8%AE%E4%BD%A0%E7%90%86%E6%B8%85%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9.md)

我时常在想，是否善恶真的是天生的，到底是什么样的家庭教育能让一个人变成如此。愿以后不会再遇到和黑子还有杨老师这样的人，要保护好自己。不忘记初心，不做最低底线的事情，不去害人，也不去占人的便宜。

### 1. ★★★ 各层协议的作用，以及 TCP/IP 协议的特点

结合 OSI 七层协议(太多太复杂) 和 TCP/IP(太少) 四层协议的优点，说一下五层协议的体系结构，自上而下介绍：

**1. application layer(应用层)**：

应用层的 **任务** 是 **通过应用进程间的交互来完成特定网络应用**。应用层协议的 **定义** 就是应用进程间通信和交互的规则。这里的 **进程** 指的就是主机中正在运行的程序。应用层协议有：**HTTP、FTP、SMTP** 等等。应用层交互的数据单元成为 **报文(message)。**

 **2. transport layer(运输层)**：

传输层的 **任务** 是负责向 **两个主机中进程之间的通信** 提供 **通用的数据传输** 服务。应用进程利用该服务传送应用层报文。运输层有 **复用** 和 **分用** 的功能，**复用** 就是多个应用层进程可以同时使用下面运输层的服务。**分用** 就是运输层把收到的信息分别交付上面应用层中的相应进程。运输层主要使用以下两种协议：

+ TCP(transport control protocol)

提供 **面向连接**的、**可靠**的数据传输服务，数据传输单位是 **报文段(segment)**。

+ UDP(User datagram protocol)

提供 **无连接**的、**尽最大努力**的数据传输服务，数据的传输单位是 **用户数据报**。

**3. network layer(网络层)**:

网络层的 **任务** 是负责 **为分组交换网上的不同主机提供通信服务**。发送数据时，网络层会把运输层产生的报文段或者用户数据报封装成 **分组** 或 **包(packet)** 进行传送。网络层使用的是 **IP 协议**，因此分组也叫做 **IP 数据报**。

网络层的 **另一个任务** 是 **选择合适的路由，使源主机从传输层下来的分组可以通过网络中的路由器找到目的主机。**

**4. data link layer(数据链路层)**:

两台主机之间的数据传输，总是在一段一段的链路上传送的。数据链路层将网络层下来的数据报组装成 **帧(framing)**，在两个相邻节点间的链路上传送 帧(frame)。每一帧都包含数据和必要的控制信息(同步信息、地址信息、差错控制等)。

**5. physical layer(物理层)**：

在物理层上所传数据的单位是 bit，物理层要考虑用多大的电压来表示 1 和 0。要确认连接电缆的插头应当有多少根引脚以及各条引脚之间应该如何连接。

通过应用进程间的交互来完成特定网络应用。应用层协议就是

#### 1.1 TCP/IP 协议的特点

这道题是在问四层模型的特点么？？？？

[知乎 TCP/IP协议到底在讲什么](https://www.zhihu.com/question/51074319) 

TCP/IP 是指能够在多个不同网络间实现信息传输的协议簇，TCP/IP 协议不仅仅指 TCP、IP 两个协议，它是在网络使用中的最基本的通信协议。TCP/IP 传输协议对互联网中各部分进行通信的标准和方法都进行了规定。并且，TCP/IP 传输协议是保证网络数据信息及时、完整传输的两个重要协议。严格来说是一个四层模型：应用层、传输层、网络层、网络接口层。

四层模型的 **特点**：(其实书上说四层模型的特点就是简单）

+ 某些程序可以直接使用 IP 层，或者直接使用下面的网络接口层。
+ TCP/IP 协议 可以为各式各样的应用提供服务，同时，TCP/IP 协议也允许 IP 协议在各式各样的网络构成的互联网上运行。IP 协议在因特网中起到了核心作用。

---------------------
### 2. ★★★ 理解三次握手以及四次挥手具体过程，三次握手的原因、四次挥手原因、TIME_WAIT 的作用。
+ **TCP**
    + TCP **建立连接**，**三次握手**
        + 首先，双方都处于监听的状态，等待客户的连接请求
        + client 向 server 发送一个 SNY 报文段（SYN=1, client_isn - 随机选择的初始序号）
        + server 收到报文段后，从中提取 TCP SYN 报文段，为该 TCP 连接分配 TCP 缓存和变量，然后向 client 发送允许连接的 SYNACK 报文段(SYN=1, client_isn+1， server_isn)
        + client 收到 SYNACK 报文段以后，客户端也要为该连接分配缓存和变量。这个报文段对服务器的 SYNACK 报文段进行了确认(server_isn+1)，又由于连接已经建立，所以 SYN=0，然后发送携带应用层的数据的报文段给 server。并且在之后的每个报文中，SYN 都会被置为 0。
        
    *其中：第二次握手 SYNACK 报文段的意思就是，我收到了你发起建立连接的 SYN 分组，该分组带初始序号 client_isn，我同意建立该连接(client_isn+1)，我自己的初始序号是 server_isn。*
        
    + **三次握手的**原因
        
        + 第三次握手是为了防止失效的数据包到达服务器，让服务器错误地打开连接。
    + 客户端的网络请求，如果在网络中发生了滞留，假设服务器要很长时间才能收到这个请求连接的数据包。客户端会等待一个超时重传的时间。重新发送请求连接的数据包。这个时候，服务器那边终于收到了这个请求连接的数据包了，然后朝客户端这里发了一个同意建立连接的数据包。这个时候客户端会因为超时而忽略这个数据包。不会进行第三次握手，因此也就不会打开连接。
        
    + TCP **释放连接**，**四次挥手**

        + A发送释放报文（FIN=1），等待B确认，此时 A 处于 FIN_WAIT_1 的状态
        + B 收到释放报文以后返回确认，A 收到确认报文时，变为 FIN_WAIT_2 状态 (此时 连接处于半关闭状态，B 可以向 A 发送数据，A 已经不能向 B发送数据了)
        + 当 B 也不需要连接的时候，发送释放报文 (FIN=1)
        + A 收到释放报文以后返回确认，进入 TIME_WAIT 状态，假定 ACK 丢失，TIME_WAIT 状态使 B 重传最后的确认报文，这个时间可能是 30s，1min，2min。
        + 经过等待以后，连接就会正式关闭，客户端所有字段，包括端口段，都将被释放。

    + **四次挥手**的原因
        
    + 1. 由于A发送了关闭连接的请求以后，B发送确认数据包，此时连接就处于半关闭的状态了。这样做是为了让B继续传送他未传完的文件部分。传送完毕以后，B端会发送FIN连接来释放报文。
        
    + **TIME_WAIT**的作用

        + 确保最后的一个确认报文能够到达，如果说B没有收到A的确认报文，就会重新发送释放请求报文，所以A要等待一段时间才会完全关闭。
        + 为了让本次连接内的所有报文在网络中消失，使得下一个连接中不会出现旧的请求连接报文。

---------------------
### 3. ★★★ 可靠传输原理，并设计可靠 UDP 协议。

虽然某些实时应用需要使用 没有拥塞控制 的 UDP，但当很多源主机同时都向网络发送高速率的实时视频流时，网络就有可能发生拥塞，结果就是大家都无法正常接收了。不使用拥塞控制的 UDP 可能会导致 严重的 网络拥塞。

可以尝试 **前向纠错** 或 **确认和重传已丢失的报文** 来提高一些可靠性措施。

---------------------
### 4. ★★★ UDP 与 TCP 比较，分析上层协议应该使用 UDP 还是 TCP。
+ **TCP特点**：

    ```markdown
    可靠数据传输原理：数据可以通过一条可靠的信道进行传输，借助于可靠信道，传输数据比特就不会收到损坏或者丢失，而且所有数据都是按照其发送顺序进行交付。这恰好就是 TCP 向调用它的因特网应用所提供的服务模型。实现这种服务抽象是 可靠数据传输协议。TCP 是在不可靠的 端到端网络层 之上实现的 可靠数据传输协议,因为底层信道太过于复杂，所以我们始终认为底层是不可靠信道(比特位置可能会出现调换，0变成1，1变成0，比特位丢失等等)。
    ```

    + **面向连接**，TCP 连接是一条逻辑连接，共同状态仅仅保留在两个通信端系统的 TCP 程序中。中间的路由器对 TCP 连接完全视而不见，它们看到的是数据报，而不是连接。每条连接都只能是 **点对点** 的。
    + **提供可靠交付**，确保一个进程从其接收缓存中读出的数据流是无损坏、无间隙、非冗余、按序的数据流。
    + **流量控制**，一条 TCP 连接的每一侧主机都为该连接设置了接收缓存，当该 TCP 接收到正确、按序的字节以后，就会将该数据放入接收缓存。相关联的应用进程则从缓存中读取数据。所以如果接收方太慢，发送方太快，就会导致 **接收缓存溢出**。因此流量控制是一个 **速度匹配服务**，即发送方的发送速率与接收方的接收速率相匹配。*TCP 底层是通过让发送方维护一个 **接收窗口** 来告诉接收方还有多少可用的缓存空间。因为 TCP 是全双工通信，在连接两段的发送方都会各自维护一个接收窗口。*
    + **拥塞控制**，TCP 发送方也可能因为 IP 网络的堵塞而被遏制。

+ **UDP特点（一样提供复用、分用、差错检测的基础功能）**

    1. **在发送数据前不建立连接**，减少了开销和发送数据的时延

    2. **尽最大努力交付**，主机不需要维持复杂的连接状态
    3. **面向报文**，对于应用层下来的报文，添加首部以后就发送给 IP 层，不会对数据报进行分片，保持数据报的完整性。因此数据报的长度靠应用层来控制，太长的话，IP 层就要负责分片，太短的话，IP 层添加首部又太长，两者的效率都不高。

    4. **没有拥塞控制**，即使网络出现拥塞也不会使源主机的发送速率降低。这对某些实时应用是很重要的：1. 要求源主机以恒定的速率发送数据。2. 允许在网络发生拥塞时丢失一些数据。

    5. **UDP 支持一对一、一对多、多对一、多对多的交互通信**。

    6. **UDP 的首部开销小**，只有 8 bytes，比 TCP 20 bytes 的首部要短。

---------------------
### 5. ★★★ GET 与 POST 比较：作用、参数、安全性、幂等性、可缓存。
+ 作用
    + GET: 向服务器获取数据
    + POST：想服务器提交数据
+ 参数
    + GET: 规范指出GET请求参数最好都放在URL里面，不建议携带请求体。参数与URI之间以逗号分开，参数之间使用&进行连接。
    + POST: 规范指出POST请求参数最好都放在请求体里面。
        + application/x-www-from-urlencoded: 将表单里面的数据转换成key-value的形式；形如key1=val1&key2=val2的方式进行URL转码。
        + raw：
+ 安全性
+ 幂等性
+ 可缓存

---------------------
### ★★☆ 以太网的特点，以及帧结构。

---------------------
### ★★☆ 集线器、交换机、路由器的作用，以及所属的网络层。

### ★★☆ IP 数据数据报常见字段的作用。

### ★☆☆ ARP 协议的作用，以及维护 ARP 缓存的过程。

### ★★☆ ICMP 报文种类以及作用；和 IP 数据报的关系；Ping 和 Traceroute 的具体原理。

### ★★☆ TCP 拥塞控制的作用，理解具体原理。

### ★★☆ DNS 的端口号；TCP 还是 UDP；作为缓存、负载均衡。

### ★★☆ HTTP 状态码。

### ★★★ Cookie 作用、安全性问题、和 Session 的比较。

### ★★☆ 缓存 的Cache-Control 字段，特别是 Expires 和 max-age 的区别。ETag 验证原理。

### ★★★ 长连接与短连接原理以及使用场景，流水线。

### ★★★ HTTP 存在的安全性问题，以及 HTTPs 的加密、认证和完整性保护作用。

### ★★☆ HTTP/1.x 的缺陷，以及 HTTP/2 的特点。

### ★★★ HTTP/1.1 的特性。

### ★★☆ HTTP 与 FTP 的比较。

### ★★☆ 五种 IO 模型的特点以及比较。

### ★★★ select、poll、epoll 的原理、比较、以及使用场景；epoll 的水平触发与边缘触发。