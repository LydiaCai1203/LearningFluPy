## Redis 篇

### 1. Redis 常见的数据结构以及使用场景

+ string

  ```markdown
  字符串类型是 Redis 最基础的数据结构，首先键都是字符串类型，其它几种数据结构都是在字符串类型的基础上构建。我们常使用的 set key value 命令就是字符串。
  **使用场景：缓存、计数、共享 Session、限速 等。**
  ```

+ hash

  ```markdown
  哈希类型是指键值本身又是一个键值对结构。**应用场景：实现购物车。**
  ```

+ list 双向链表

  ```markdown
  用来存储多个有序的字符串。**应用场景：简单的消息队列的功能。**
  ```

+ set 集合

  ```markdown
  set 类型也是用来保存多个的字符串元素，集合中不允许有重复的元素，且集合中的元素是无序的，不能通过索引下标获取元素，利用 set 的交集、并集、差集等操作。
  **应用场景：计算共同喜好，全部的喜好，自己独有的喜好 等功能。**
  ```

+ sorted set 集合

  ```markdown
  多了一个权重参数 score, 集合中的元素能够按照 score 进行排列。**应用场景：排行榜应用，取 TOP N 操作。**
  ```

### 2. Redis 持久化的几种方式

Redis 的 **持久化策略** 有两种：

+ **RDB（Redis 默认持久化策略）**

  在指定的时间间隔内将内存中的数据集快照写入磁盘，实际过程是 fork 一个子进程，子进程将数据写到磁盘上的一个临时 RDB 文件中，写入成功后，以二进制压缩存储，一个 dump.rdb 文件。这样做的 **好处** 就是可以 **copy-on-write**。当然也可以手动执行 save 或 bgsave 做快照。

  + **优势**
    1. 在发生灾难时轻松 **还原** 数据集的 **不同版本**。
    2. RDB 文件是一个 **紧凑** 的文件，二进制存储嘛，可以进行远程传输。
    3. RDB 最大限度地提高了 Redis 的 **性能**，因为 父进程 的唯一工作就是分派 一个孩子进程，孩子进程会完成剩下工作。父进程不会执行 I/O 操作。
    4. 与 AOF 相比，RDB 允许大型数据集服务器**更快地重启(AOF在重启之前要重新执行一遍 AOF 日志文件，所以说更快)**。
  + **缺点**
    1. 即使每 5min 创建一次 RDB 快照，Redis 出现故障停止工作，还是会 **丢失几分钟的数据**。
    2. **RDB 经常使用 fork**，如果数据集很大，fork 可能很耗时，万一数据集很大，CPU 性能不佳，则可能导致 Redis 停止为客户端服务几毫秒甚至一秒。

+ **AOF** 

  记录服务器接收的每个写入操作，这些操作将在服务器启动时进行重放，以重建原始数据集。仅采用追加的方式，当日志太大时，Redis 可以在后台重写日志。每一个写命令都通过 write 函数追加到 appendonly.aof 中。appendonly.aof 以文本的方式记录。

  + **优势**
    1. **最多只丢失 一秒钟 的数据**。AOF的默认策略是每秒钟 fsync 一次。且 fsync 的性能良好。fsync 会在后台线程执行，所以主线程可以努力地处理命令请求。
    2. AOF 日志是仅追加的日志，**如果断电，不会出现寻道或者损坏的问题**。（？？没明白）
    3. Redis 会在后台自动重写 AOF，**重写是完全安全的**，追加时会生成一个全新的文件，其中包含创建当前数据集所需要的最少操作集，一旦准备好第二个文件，Redis 会切换这两个文件并开始追加到新的那一个。
    4. **AOF 以易于理解和解析的格式书写操作日志**。可以轻松导出 AOF 文件，修改 AOF 文件(删除命令等等)，然后重新启动 Redis 即可。
  + **缺点**
    1. 对于相同的数据集来说，AOF 的文件体积通常 **要大** 于 RDB 文件的体积。
    2. 根据所使用的 fsync 策略，AOF 策略可能 **会慢** 于 RDB。关闭 fsync 可以让两者的速度一样快，即使在高负荷之下也是如此。

+ **总结**

  因此如果可以在发生灾难时承受几分钟的数据丢失，则可以使用 RDB。另外 **不建议单独使用 AOF**，因为它会将每一条命令都追加到磁盘中，处理巨大的写入会 **降低** Redis 的 **性能** 。因此我觉得定时生成 RDB 快照(比如 每5min 生成一次快照)，同时开启 RDB 和 AOF(比如每 5min 重写一次)，这样系统重启以后会优先使用 AOF 来恢复数据，这样丢失的数据最少。对于主从同步来说，主从刚刚连接时，进行全量同步，全量同步结束以后，进行增量同步。

### 3. Redis 的 LRU(Last Recent Used) 具体实现(这个答案保持疑问，文档似乎不是这样写的)

据说是以前头条的面试题

#### Last Recent Used 是什么？

因为计算机的缓存容量有限，缓存满了就需要删除一些内容，给新的腾位置。LRU 就一种常用的页面置换算法，选择最近最久未使用的页面予以淘汰。

#### 自己实现 LRU 算法

数据结构的选法很重要，要求查找快(查找放入插入键之前是否存在)，插入快(如果不存在的话就插入队头)，删除快(容量满了删除队尾数据)，且有顺序，因为有最近使用和久未使用的顺序之分。如果插入键存在，则还可能要将队中的数据挪到队头。

**hash 表**：查找快，但是数据无固定顺序

**链表**：插入、删除都快，但是查找慢

因此就有了一种新的数据结构，**哈希链表**。

因此 hash 表里 key 存储节点的 值，value 存储 指向节点的指针，就可以实现以上目的了。链表的话可以使用双向链表，或者单链表吧。**要注意的是**，在处理链表节点的同时，不要忘记更新哈希表中对节点的映射。

#### Redis 的实现

Redis 作为缓存使用时，要考虑内存空间消耗的问题。Redis 会删除过期键释放空间(有惰性删除、定期删除)。另外 Redis 也可以开启 LRU 功能来自动淘汰一些键值对。

**初始版本中**：Redis 每次按照 key 获取一个值时，都会更新 value 中的 LRU 字段为当前秒级别的时间戳。因此随机从 Dict 中取出 5 个 key，淘汰一个 LRU 字段值最小的。

**3.0版本中：**首先第一次随机选取的 key 都会放进 pool 中(pool 的大小为 16)，接下来每次随机选取的 key 的 LRU 值 **必须小于** pool 中最小的才会继续放入，pool 中的 key 是按照 LRU 大小顺序排列的，直至将 pool 放满。再之后，如果有新的 key 需要放入，需要将 pool 中最大的 key 取出，放入。淘汰的时候，直接取出 pool 中最小的 LRU 的 key 进行删除。

**4.0版本中：**引入新的 LFU(最不常用) 驱逐策略。LFU 尝试跟踪物品的访问频率，因此，很少使用的数据会被驱逐，经常使用的数据则有较高的机会保留在内存中。

### 4. 单线程的 Redis 为什么快？

CPU 并不是您使用 Redis 的瓶颈，因为 Redis 是和 **内存** 与 **网络** 绑定的。例如，一般 Redis 每秒可以发送 100W 个请求。因此，如果您的应用程序主要使用 O(N) 或 O(logN) 命令，则几乎不会过多使用 CPU。使用多线程带来的性能成本并不能抵消它带来的开发成本和维护成本，系统的性能瓶颈也主要在网络 IO 操作上。并且这里的单线程指的是 处理客户端的命令，前文介绍的 RDB 和 AOF 都是 fork 出子进程去做的。

+ **完全基于内存**

+ **采用单线程，避免了不必要的上下文切换和竞争条件，不用考虑各种锁的问题(加锁、释放锁)，没有因为可能出现死锁而导致的性能消耗。**
+ **采用 IO 多路复用模型**
+ 避免了多进程引入导致代码实现复杂度的提升，减少了出错的可能性。----（为什么不适用多线程/多进程）

#### 4.1 进程线程是什么，区别是什么，各自的优缺点是什么？

#### 4.2 什么是 多路 I/O 复用模型？Redis 的 多路复用应用？

**多路：**多个客户端连接(连接就是套接字描述符 FD)

**复用**：使用单进程能够实现同时处理多个客户端的连接

在当代 Unix 操作系统中提供了 **`select`**、**`poll`**、**`epoll`** 这样的 system call，这些 system call 的功能就是：你告诉我一批 socket，当这些套接字的 可读/可写 事件发生时，我会通知你这些信息。多路 IO 复用模块相当于 socket 和 处理者 之间传话的一个中介。这样 CPU 就可以实现对 **多个** FD 的 **同时读写** 了。

**Redis 里采用了 Reactor 设计模式**

(多个 socket) -> 多路IO复用程序 -> 文件事件分派器 -> 个字的文件事件处理器。(比如：命令请求处理器、命令回复处理器、连接应答处理器)。

这里可以减少网络 IO 的时间消耗，避免无用操作，但是文件事件的处理，依旧还是顺序处理的。

**一点很杂的知识：**

`select` 函数是作为 POSIX 标准中的系统调用，在不同版本的操作系统上都会实现，因此，在 Solaries10 上，Redis 会用 `enport`，在 Linux 上用 `epoll`，在 OSX 和 FreeBSD 上使用 `kqueue` 和 `select`(备选机制)。前三个的时间复杂度都是 O(1)，`select` 是轮询机制，所以是 O(N)。 

### 5. Redis 的数据过期策略

+ **定期删除策略**

  Redis 启用一个定时器定时监视所有的 key，判断 key 是否过期，过期的话就删除。

  **优点**：这种策略可以保证过期的 key 最终都会被删除。**缺点**：每次都要遍历内存中的所有数据，**非常消耗** CPU 资源，并且当 key 已经过期，但是定时器还处于未唤起状态，这段时间内的 key 也仍然是可用的。

+ **惰性删除策略**

  在获取 key 时，先判断 key 是否过期，如果过期则删除。

  **优点**：不用每次都遍历内存中的策略了，而且可以保证超过过期时间以后肯定获取不到。**缺点**：如果这个 key 一直未被获取，则会一直存在于内存中，浪费空间。

+ **结合使用**

  定时删除策略随机抽取一部分的 key 进行检查，降低 CPU 的消耗。惰性删除则不变。

  **所以有的数据既没有被定时器抽取到，也没有被使用到，那么这些数据如何从内存中消失呢？**

#### 内存淘汰机制(当内存不足以容纳新写入的数据时)：

+ 新写入操作就会报错。（Redis **默认策略**）
+ 在键空间中，移除最近最少使用的 key。(LRU)
+ 在设置了过期时间的键空间中，移除最近最少使用的 key。这种情况一般把 Redis 当作缓存，但是又需要做持久化存储的时候使用。(why??)

### 6. 如何解决 Redis 缓存雪崩的问题？

缓存雪崩是指某一时刻发生大规模的缓存失效的情况，比如 缓存服务器宕机了。这时就会有大量的请求直接打到 DB 上，DB 撑不住，就挂掉了。

+ **雪崩前** - 使用 Redis **集群**缓存，保证缓存服务高可用。
+ **雪崩前** - 我们在设置缓存的时候，一般会给缓存设一个 **失效时间**。那么对于一些热点数据来说，如果设置一样的缓存失效时间就可能会发生缓存雪崩，因此解决方案就是 设置 **不同的** 缓存失效的时间。
+ **雪崩中** - **限流降级策略**。**限流**就是提高各个类型的请求设置最高的 QPS 值，**如果高于** 阈值之后的请求直接返回，不再调用后续的资源。**降级** 就是当服务器压力剧增的情况下，根据当前业务情况及流量对一些服务和页面有策略的降级，从此 **释放服务器资源** 以保证核心任务的正常运行。

### 7. 如何解决 Redis 缓存穿透的问题？

缓存击穿是指当大量请求去请求缓存中不存在的 key 时，这是请求就会集中到 DB 上，导致 DB 压力剧增。

+ 在查询缓存之前，采用 **布隆过滤器**，将所有可能存在的数据 哈希 到一个很大的 bitmap 中去。如果查询的数据在布隆过滤器中不存在，则不查询缓存。
+ **加互斥锁**，在第一个查询数据的请求上使用互斥锁，查到数据以后做缓存，后面的线程进来发现有缓存了，就会直接走缓存。
+ 将 不存在的 key 存进 Redis，**`set key null`**，过期时间设的很短，不超过 5 分钟。我感觉这个没啥用吧，首先就是能保证 5min 内不把内存打爆？其次就是，缓存不存在的 key 有意义么，不存在缓存中随机找的 key 太容易找到一大堆了吧。

### 8. Redis 并发竞争 key 如何解决

就是说当有多个 redis-client 同时 set 用一个 key 时。

+ 在分布式环境，加 **分布式锁**。用一个状态值表示锁，对锁的占用和释放都通过状态值进行标识。适用于 **无顺序需求** 的场景。
+ 利用 **时间戳** 和 **消息队列**。适用于 **有序需求** 的场景。

### 9. Redis 的主从模式、哨兵模式、集群(cluster)模式 之间的区别

#### 9.1 主从模式：

通过 `slaveof` 命令让一个服务器去复制另一个服务器的数据。被复制的服务器成为：**master 主服务**。对主服务器进行复制的服务器成为：**slave 从服务器**。主数据库可以进行读写操作，当写操作导致数据发生变化时，**自动(?)** 将数据同步给从数据库。从数据库一般是只读的。主从数据库是一对多的关系。

**通信过程(异步复制)**：

1. 从服务器 向 主服务器 发送 SYNC 命令
2. 主服务器收到命令后，执行 BGSAVE 命令，在后台生成 RDB 文件。收集缓冲区记录里，从现在开始执行的所有操作记录。
3. 主服务器 BGSAVE 执行结束后，主服务器将 RDB 文件 和 操作记录 发给从服务器。

**主从模式的问题：当 master 挂了，需要在 slave 中选举一台成为 master，要实现自动，就需要 redis 哨兵。**

#### 9.2 哨兵模式(Sentinel)

哨兵模式核心仍是主从模式，但是多了竞选机制，可以从挂了的主节点的从节点中竞选出新的主节点。竞选机制的实现，依赖于 Sentinel 进程。

**Sentinel 特点**：

+ **监控**：坚听 主服务器 和 从服务器 之间是否正常工作
+ **通知**：能通过 API 告诉系统管理员或程序，集群中的某个实例出现了问题
+ **故障转移**：它在主节点出问题的情况下，会从出问题的主节点下的从节点中竞选出一个节点成为新的主节点
+ **提供主服务器地址**：它还能够向使用者提供当前主节点的地址。故障转移后，使用者不用做任何修改就可以知道当前主节点地址。

Sentinel，也可以集群，也可以部署多个。Sentinel 可以通过发布订阅自动发现集群中的其它 Sentinel。所有的 Sentinel 都会存储在一个列表中，**因此集群中的 Sentinel 不会并发着去对同一个节点进行故障转移。**故障转移只会从第一个 Sentinel 开始，当第一个转移失败后，才会尝试下一个。

当竞选出新的主节点后，被选为新的主节点的从节点的配置信息会被 Sentinel 改写为旧的主节点的配置信息。完成改写后，再将新主节点的配置广播给所有的从节点。

#### 9.3 集群模式

-- **集群** 是 Redis 提供的分布式数据库方案，通过分片进行数据共享， 分片是为了解决数据量过大在单个节点上造成巨大压力的问题，它能带来：

1. 自动对数据分片，落到各个节点上。
2. 当一部分节点出现故障或无法与其余集群通信时，仍然可以继续工作

-- 每个 Redis 集群里的节点，都需要打开 **两个 TCP 端口**，否则集群无法正常工作。

+ 普通的 **命令端口** 如 6379，用于服务客户端。
+ 在普通端口加1000，如 16379，称为 **集群总线端口**，用于故障检测、配置更新、故障转移授权等等。客户端永远不要尝试与集群总线端口通信。

（命令端口 和 集群总线端口 的偏移是固定的，始终是 1000）

--在 Redis 集群中，**哈希槽** 其实就是 **虚拟的** 很小粒度的 **分区**，通过 hash 算法将数据存放于对应的槽中。集群中会虚拟出 16384 个槽位来存储数据集，这 16384 个槽位会分别映射到各个节点上。**存储时**，对要存储的键位进行 crc16 哈希运算，得到一个值，取模 16384，判断在哪个节点范围区间。**查询时**，同样进行哈希计算，然后判断数据存储在哪个节点。**优点**：将哈希槽从一个节点移动到另一个节点 **不需要停机操作**，所以添加、删除、更改节点持有哈希槽的百分比不需要任何停机时间。

#### 9.4 集群一致性保证

Redis Cluster 无法保证 **强一致性**。在某些情况下，可能丢失系统认可给客户端的写入。

**第一个原因：使用异步复制。**

+ client 在 主B 执行写操作
+ 主B 向 client 答复"确定"
+ 主B 将写操作传播到 从B1、从B2、从B3

B在回复客户端之前 **不会等待** B1、B2、B3 的 **确认**，因为这会对 Redis 造成极高的延迟影响。这时如果这个 主B 挂了，写操作还没同步过去，从B 竞选为 主B，这样就会永远丢失写操作。

**解决方案：**

当然可以强制在 主B 回复 客户端之前，同步给 从B 们。这是性能和一致性之间的权衡。

但即使使用 **同步复制**，Redis Cluster 也 **无法实现** 强一致性。因为在更复杂的故障情况下，总是有可能将无法接受写入的从设备选为主设备。

**第二个原因：Redis Cluster 可能丢失写数据，这种情况发生在网络分区期间，在该分区中，客户端与少数实例隔离**

假如我们的集群有 6 个节点，三主三从(A，B，C，A1，B1，C1)。有一个客户 Z1。发生分区后，可能在分区的一侧有 A, C, A1, B1, C1, 而另一侧有 B 和 Z1。Z1 能写入 B，B 也接受其写入。如果分区持续的时间足以让 B1 升级为该分区的多数端的主服务器，那么 Z1 在此期间发送给 B 的写入将丢失。

### 10. Redis 事务的了解。 CheckAndSet 操作实现乐观锁

**简介：**

+ [Redis 事务](https://redis.io/topics/transactions)里所有的命令都会 **被序列化** 然后 **被顺序执行**，在事务执行过程中，不会再为其它客户端的请求提供任何服务，从而保证事务中的所有命令原子性执行。Redis 的事务也是原子的，要么全部不执行，要么全都执行。

+ 事实上在执行事务中的命令发生错误时，**Redis 不会进行回滚**，而是继续向下执行完剩下的命令。因为 Redis 命令可能失败的原因只可能是语法错误或者使用了错误的数据类型。失败的命令会返回失败的结果，因此失败往往在开发时候就发现了，不会出现在生产中。Redis 会因为没有回滚而变得 **更简单更快**。

**使用：**

```shell
> MULTI          # 收到 OK 后，意味用户可以发出多个命令
OK
> INCR foo       # 命令排队
QUEUED           # 回复 QUEUED 表示命令已开始正常排队，如果返回错误，则应该中止该事务并将其丢弃
> INCR bar      
QUEUED
>EXEC            # 执行所有命令，返回答复数组，每个元素都是单个命令的答复，顺序与发出的命令顺序相同
1)(integer) 1
1)(integer) 1    # 假如在第二部执行之前，第一步执行之后，Redis 服务器挂了，此时你使用的还是 AOF 持久化机制，Redis 重启时会发生错误然后退出。
                 # 这时可以使用 `redis-check-aof` 修复日志文件，删除之前注册了的部分事务，以便服务器可以重新启动。
```

```shell
> SET foo 1
OK
> MULTI
OK
> INCR foo
QUEUED
> DISCARD        # 中止事务，不执行任何命令
OK
> GET foo
"1"
```

#### 10.1 使用 check-and-set 操作 实现 乐观锁

乐观锁是为了解决多客户端同时对一个 key 进行操作，导致操作未生效，或者操作结果错误的情况。乐观锁就是认为不会发生并发问题，因此不会对数据上锁，如果数据发生变化，则当前操作失效。

`WATCH` 命令被用来提供 check-and-set 行为。具体使用如下：

```shell
WATCH mykey            # watch 将检测其更改，若在 EXEC 之前至少修改了一个监视键，则当前事务会被中止。
val = GET mykey
val = val + 1
MULTI
SET mykey $val
EXEC                   # 若事务中止，EXEC 返回 null 答复以通知该事务失败
```

ps:

一个 Redis 脚本 就是 事务性的，所有的事务能做的，用 Redis 脚本也可以做。且会更简单更快速，但是由于 事务 先于 脚本存在，因此删除不太合理。但如果有一天所有的用户都是用 Redis 脚本，Redis 表示可能会选择弃用或删除事务。

### 11. Redis 有序集合 zset 底层是如何实现的？

由于需要数据 **有序**，所以马上想到 list 和 array。现在看看插入数据时候这俩种数据结构的性能：

**Array**: 由于在查找插入位置的时候可以使用二分查找，因此时间复杂度是 O(lgN)，在插入数据的时候，所有的插入位置右边的数据要右移，因此是 O(N)

**List**: 查找插入位置的时候无法用二分，因此是 O(N), 但是插入很快，只要 O(1) 即可。

对于百万，千万的数据来说，还是太慢了。因此我们选择 **跳跃表(skiplist)**，跳表是一种 **基于有序链表** 的扩展。

**怎么能快速查找一个有序链表的某一个节点呢？**

```markdown
可以利用类似索引的思想，**提取** 出链表中部分的 **关键节点**，比如所有值为奇数的节点。这样就可以确定节点范围，然后再找到具体的位置。有了这样的思想，不难想到如果在第一层节点基础上进一步提取，**保证每一层是上一层节点数的一半**。于是有了第二层节点。这样当节点很多的时候，比较次数就会变成原来的 1/4。这样多层链表的结构，就是所谓的 **跳跃表**。每个索引节点都包含两个指针，一个向下，一个向右。
```

**那么当插入节点的个数越来越多，怎么选择关键节点插入节点，怎么淘汰关键节点呢？**

```markdown
跳跃表的设计者，随机决定新节点是否提拔，每向上提拔一层的几率是 50%。就和 抛硬币 一样。原因是因为跳跃表的删除和添加是无法预测的，因此很难有一种算法保证跳跃表的索引分布始终均匀。
```

**跳表的时间复杂度呢？**

```markdown
查找、插入、删除 都是 O(logN) 
```

**空间复杂度呢？**

`O(N)`

**跳表和二叉树的区别？**

```markdown
跳表的优点是维持平衡的成本低，完全靠随机。二叉树在多次插入删除以后，需要 rebalance 来重新调节结构平衡。
```



































