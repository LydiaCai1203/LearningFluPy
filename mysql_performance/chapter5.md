# chapter 5 创建高性能的索引

## 5.1 索引基础

​		在 MySQL 中，其先在索引中找到对应值，然后根据匹配的索引记录找到对应的数据行。

[文档 优化和索引](https://www.docs4dev.com/docs/zh/mysql/5.7/reference/mysql-indexes.html)

### 3.1.1 索引的类型

​		索引是在存储引擎层，而不是服务器层实现的。不同的存储引擎，工作方式和实现都可能是不同的。

#### **B-Tree 索引（pk、unique、index、fulltext）**

​		**基本特征：** *1*. 多路节点 *2.* 一个树节点中有多个数据，数据个数大于等于 N 时，分裂成左中右三个部分，中间节点变成左右两部分的父节点。 *3.* 所有的叶子节点都是一条有序链表。 *4.* 所有的数据都在叶子节点上。

​		**MyISAM** 使用 前缀压缩索引技术 让索引更小。通过数据的物理位置引用被索引的行。

​		**InnoDB** 按照原数据格式进行索引。通过主键引用被索引的行。

​		所有的值都是按照顺序存储的，并且每一个叶子页到跟根的距离相同。*叶子节点的指针指向的是被索引的数据*，而不是其它的节点页。不同存储引擎的指针类型不相同。索引对多个值排序的依据是 `create table` 语句中定义索引时列  的顺序。B-Tree 索引适用于全键值、键值范围或键前缀查找。



**联合索引对以下查询有效**

```sql
CREATE TABLE People (
	last_name varchar(50) not null,
  first_name varchar(50) not null, 
  dob date not null,
  gender enum('m', 'f') not null,
  key(last_name, first_name, dob)   -- 联合索引，最多包含 16 列
);
```

+ **全值匹配**

  指和索引中的所有列进行匹配。如：查找姓名为 Goodman Austin 且 1970年生的数据。

+ **匹配最左前缀**

  指和索引中的前一列，前两列，前三列 进行匹配。如果不是按照最左列开始搜索的，怎无法使用索引。也不能跳过某些列，必须是连续的。如果查询中有某个列的范围查询，则其右边所有的列都无法使用索引优化查找。

+ **匹配列前缀**

  指匹配某一列值的开头部分。如：查找姓开头为 A 的人。

+ **匹配范围值**

  对某一列进行范围搜索。如：查找姓在 Allen 和 Barrymore 之间的人.(??)

+ **精确匹配一列并范围匹配另一列**

+ **只访问索引的查询**

  指只需要访问索引、无须访问数据行。比如覆盖索引。

+ *排序请求*

  索引树中的节点是有序的，索引可以用于查询中的 `order by` 操作。如果 `order by` 子句满足前面列出的几种查询类型，则这个索引也可以满足对应的排序需求。

**tips: 索引列的顺序是很重要的，这些限制都和索引列的顺序有关。在优化性能的时候，可能需要使用相同的列，但是顺序不同的索引来满足不同类型的需求。这些限制并不是 B-Tree 本身导致的，而是优化器和存储引擎使用索引的方式导致的。也就是说这是可以优化的。**

#### 哈希索引

​		**基本特征：** 基于哈希表来实现的，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的**索引列**计算一个哈希码(hash code), hash code 是一个较小的值，并且在不同键值的行计算出来的 hash code 也不一样。哈希索引将所有的哈希码都存储在索引中。同时在哈希表中存储指向每个数据行的指针。

​		**在 MySQL 中只有 Memory 引擎显示支持哈希索引**，也是默认索引。Memory 引擎支持非唯一哈希索引，如果多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一个哈希条目中。 也就是说哈希表只包含行指针，但是不包含行数据。

​		**使用方式：**

```sql
CREATE TABLE testhash (
	fname VARCHAR(50) NOT NULL,
  lname VARCHAR(50) NOT NULL,
  KEY USING HASH(fname)
) ENGINE=MEMORY;
```

​	**缺点：**

1. 由于 hash 表中不存储数据，所以无法通过访问 hash 表，避免访问数据行。
2. 哈希索引数据不是顺序存储的，所以无法用于排序。
3. 不支持部分索引列匹配查找。因为哈希值是使用索引列的所有字段内容进行计算的。
4. 只支持等值查询，不支持任何范围查询。
5. 访问哈希索引的速度非常快，除非有很多的哈希冲突。存储引擎需要遍历行指针上的每一个，逐行比较，直到找出所有符合的行。
6. 同上，假如有很多的哈希冲突，删除的代价就会越大。

**自适应哈希索引**

​		InnoDB 的一个特性，当 InnoDB 注意到许多索引值被频繁地使用到时，他会在内存中基于 B-Tree 的索引再见一个哈希索引，这是一个完全自动的、不可配置的行为。但是用户可以选择关闭它。

**创建自定义哈希索引**

​		现在有一个例子，需要存储大量的 URL, 并根据需要的 URL 进行搜索查找。如果使用 B-Tree 来存储 URL，存储的内容就会很大，因为 URL 本身都很长。若删除原来 URL 列上的索引，而新增一个被索引的 url_cc 列，使用 CRC32 做哈希(返回的是一个32位整数，当索引有 93000条 的时候出现冲突的概率是 1%)，就可以使用以下的查询。

​		`SELECT id FROM url WHERE url='http://www.mysql.com' AND url_cc=CRC32('http://www.mysql.com');`

​		只需要根据哈希值做快速的整数比较就能找到索引条目，查找相对于比对完成的 URL 字符串做索引要快得多。这个 url_cc 可以通过手动维护，也可以通过触发器实现。
​		**千万不要使用 SHA1() 和 MD5() 作为哈希函数，因为这两个函数计算出来的哈希值是非常长的字符串，会浪费大量的空间，比较的时候会更慢。SHA1() 和 MD5() 是强加密函数，设计目标是最大限度消除冲突。但是如果数据表非常大，CRC32() 则会产生大量的哈希冲突，或者可以自己实现一个简单的 64位 哈希函数，这个自定义函数要返回整数，而不是字符串。**
​		要想解决这样的问题，必须要索引值和原值同时搜索，才能保证搜索结果正确。
​		还可以使用 FNV64() 来作为哈希函数，速度快，且产生冲突要比 CRC32() 小很多。

#### 空间数据索引(R-Tree)
​		不是很理解，所以不在这里记录了。

#### 全文索引
​		查找的是文本中的关键词，而不是直接比较索引中的值。全文搜索和其它索引的匹配方式完全不一样。需要注意停用词、词干、复数、布尔搜索等。全文索引适用于 MATCH AGAINST 操作，而不是 WHERE 条件操作。InnoDB 对全文索引使用反向列表。

#### 其它索引类别
​		不理解，不记录了。

## 5.2 索引的优点
1. 索引大大减少了服务器需要扫描的数据量。
2. 索引可以帮助服务器避免排序和临时表。
3. 索引可以将随机 I/O 变成顺序 I/O。

**索引评分**

1. 索引将相关的记录放在一起则获得一星。
2. 如果索引中的数据顺序和查找中的排列顺序一致则获得二星。
3. 如果索引中的列包含了查询中需要的全部列则获得三星。

## 5.3 高性能索引策略
​		正确地创建和使用索引是实现高性能查询的基础。

### 5.3.1 独立的列
​		一些查询不当地使用索引，或者是的 MySQL 无法使用已有的索引。如果查询的列不是独立的，则 MySQL 就不会使用索引。"独立的列" 是指索引列不能是表达式的一部分，也不能是函数得到参数。
​		如：`SELECT actor_id from actor where actor_id + 1 = 5;` 或者是 `SELECT ... WHERE TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10;`

### 5.3.2 前缀索引和索引选择性
​		有时候索引很长的字符列，这会是的索引变得大且慢，一个策略是前面提到过的模拟哈希索引。遇到这种情况通常可以**索引开始的部分字符**。**优点**（节约索引空间，提高索引效率）**缺点**（降低索引的选择性）, 所谓的 *索引选择性* 是指 **不重复的索引值(基数，cardinality)** 和 **数据表的记录总数** 的比值。索引选择性越高则查询效率越高，因为选择性高的索引可以让 MySQL 在查询的时候过滤掉更多的行。唯一索引的选择性是 1，性能是最高的。也就是说，当需要对 `VARCHAR`(很长的) 或者 `BLOB` 或者 `TEXT` 进行索引时，既要选择足够长的字符来保证其选择性，又不能太长以节约存储空间。
​		可以使用 `GROUP BY` 来看选择性，举个例子：
```sql
  select LEFT(`t_domain_info`.`f_domain`, 7) AS pre, count(1) as num
  from `t_domain_info`
  group by pre
  order by num desc;    -- 417 rows

  select count(1)
  from t_domain_info;   -- 831 rows

  select 417 / 831;     -- 选择性 0.5018
```
​		或者是另一种方式：
```sql
select count(distinct `f_domain`)/count(*)
from `t_domain_info`    -- 1
```
​		创建前缀索引的方式：
```sql
alter table t_domain_info add key(f_domain(7));
```
**优点**：索引更小，更快。**缺点**：无法使用前缀索引做分组聚合、排序、覆盖扫描。**某下场景下后缀索引也会起到不错的效果，比如对邮箱后缀进行索引，但是 MySQL 并不支持反向索引，因此可以把字段值反置。**

### 5.3.3 多列索引
​		一个常见的对索引错误理解就是，为每个列创建独立的索引，或者按照错误的顺序创建多列索引。

**为每个列创建独立的索引：**

```sql
CREATE TABLE t (
  c1 int,
  c2 int,
  c3 int,
  KEY(c1),
  KEY(c2),
  KEY(c3)
)
```

​		在多列上建立独立的单列索引，大部分并不能提高 MySQL 的查询性能。MySQL 5.0 引入了一种 **"索引合并"** 策略，一定程度上可以使用表上的多个单列索引来定位指定的行。假如不想使用的话可以用 **optimizer_switch** 进行关闭。

​		在老版本中以下 SQL 语句会进行全表扫描。

```sql
SELECT film_id, actor_id
FROM actor
WHERE actor_id = 1 OR film_id = 1;	
```

​		除非改写成如下的两个查询，然后使用 union 的方式。这样可以同时使用两个单列索引进行扫描，并将结果进行合并。下面这种 SQL 还可以写成：OR条件的联合、AND条件的相交、组合前两种情况的联合及相交。也就是说上面那种写法是可以使用单列索引的, MySQL 会对其采用索引合并的策略。

```sql
SELECT film_id, actor_id 
FROM actor
WHERE actor_id = 1
UNION ALL
SELECT film_id, actor_id
FROM actor
WHERE film_id = 1 AND actor_id <> 1;
```

**联合索引的出现说明索引建的很糟糕：**

+ 当服务器对多个索引做相交操作时，通常有多个 AND 连接，意味着需要一个包含所有相关列的多列索引，而不是多个独立的单列索引。
+ 当服务器需要对多个索引做联合操作时，通常多个 OR 连接，意味着需要消耗大量的 CPU 和 内存资源 在算法的缓存、排序、合并操作上。特别是当其中有些索引的选择性并不高，需要合并扫描返回的大量数据的时候。
+ 优化器只关心随机页面的读取，这样会是的查询成本被“低估”，导致该执行计划还不如直接走全表扫描。这样做不但会消耗更多的 CPU 和 内存资源，还可能会影响查询的并发性。

### 5.3.4 选择合适的索引列顺序

​		在一个多列的 B-Tree 索引中，索引列的顺序意味着索引首先按照最左列进行排序，其次是第二列。所以，索引才可以按照升序或者是降序进行扫描，以满足精确符合列顺序的 ORDER BY、GROUP BY、DISTINCT 等子句的查询需求。

​		有一个经验法则是：当不需要考虑排序和分组是，将选择性最高的列放到索引的最前列通常是很好的。这时候索引的作用只是用于优化 WHERE 条件的查找。实际上可以根据查询频率高的语句来确定索引列的顺序。下面这个例子中显然应该将结果较小的字段放在索引列的前面，因为 SUM 值越小说明选择性越高。

```sql
SELECT * FROM payment WHERE staff_id = 2 AND customer_id = 584;
SELECT SUM(staff_id = 2), SUM(customer_id = 584) FROM payment \G;
```

​		但是面的操作对具体的值有很强的针对性，如果没有类似的具体查询来运行，最好的做法还是按照经验法则来做。

```sql
SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
	COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity
	COUNT(*)
FROM payment\G;
```

### 5.3.5 聚簇索引

[MySQL doc](https://dev.mysql.com/doc/refman/5.7/en/innodb-index-types.html)

​		**聚簇索引并不是一种单独的索引类型，而是一种数据存储方式(存储引擎负责实现)。具体的细节依赖于其实现方式**。

​		当表有聚簇索引时，它的数据行实际存放在索引的叶子页(leaf page)中。术语“聚簇”表示 **数据行和相邻的键值紧凑地存储在一起。** 因为无法同时把数据行存放在两个不同的地方。所以一个表只能有一个聚簇索引。**叶子页包含了行的全部数据，但是节点页只包含了索引列。**

​		InnoDB 通过主键聚集数据，也就是说索引列里面存的是主键。如果没有定义主键，InnoDB 会选择一个唯一的非空索引代替。如果没有这样的索引，InnoDB 会隐式定义一个主键作为聚簇索引。InnoDB 只聚集在同一个页面中的记录，包含相邻键值的页面可能会相距甚远。

**优点：**

+ **可以把相关的数据保存在一起。**例如实现电子邮箱时，可以根据用户 ID 来聚集数据。这样只需要从磁盘上读取少数的数据页就能获取某个用户的全部邮件了。如果没有使用聚簇索引，则每封邮件都可能导致一次磁盘 I/O。
+ **数据访问更快。** 
+ **使用覆盖索引扫描的查询可以直接走叶节点中的主键值。**

**缺点：**

+ **最大限度地提高了 I/O 密集型应用的性能**，但如果数据全部都放在了内存中，那么访问的顺序就没那么重要，聚簇索引也就没有什么优势了。

+ **插入速度严重依赖于插入顺序。** 按照主键的顺序插入 是加载数据到 InnoDB 表中速度**最快的方式。**如果不是按照主键顺序加载数据，在加载完成后最好使用 `optimize_table` 命令重新组织一下表。

+ **更新聚簇索引的代价很高。** 因为会强制 InnoDB 将每个被更新的行移动到新的位置。

+ **基于聚簇索引的表在插入或更新时，可能面临 页分裂(page split) 的问题。可能会导致表占用更多的磁盘空间。**

+ **可能导致全表扫描变慢。** 尤其是 行比较稀疏，或是，由于页分裂导致数据存储不连续的时候。

+ **二级索引 可能会比想象地要更大。** 因为在二级索引的叶子节点包含了引用行的主键列。

+ **二级索引访问需要两次索引查找，而不是一次。**

  二级索引叶子节点保存的不是指向行物理位置的指针，而是行的主键值。存储引擎现在二级索引中找到对应的主键值，然后再按照这个值去聚簇索引中找到对应的行。这里就进行了两次 B -Tree 查找。对于 InnoDB, 自适应哈希索引能减少这样的重复工作。

##### InnoDB 和 MyISAM 的索引数据分布对比

```sql
CREATE TABLE layout_test(
	col1 int NOT NULL,
  col2 int NOT NULL,
  PRIMARY KEY(col1),
  KEY(col2)
);
```

​		假设该表的主键取值为 1～10000， 按照随机顺序插入后，使用 OPTIMIZE TABLE 命令做优化。但是行的顺序是随机的。col2 的取值范围是 1~100，有很多的重复值。

##### MyISAM 的数据分布

+ *存储行号和索引列值*，按照数据插入的顺序存储在磁盘上。在行的旁边显示了行号，从0开始递增，因为行是定长的，所以 MyISAM 可以从表的开头跳过所需的字节找到需要的行。(定长和变长的行使用不同的策略。)

**InnoDB 的数据分布**

+ *InnoDB 中，聚簇索引就是表，不需要独立的行存储。*聚簇索引的每一个叶子节点都包含了主键值、事务ID、用于事务和MVCC的回滚指针以及所有的剩余列。如果主键列是前缀索引，InnoDB 也会包含完整的主键列和其它剩余的列。

+ InnoDB 二级索引的叶子节点中存储的不是“行指针”，而是主键值，以此作为指向行的“指针”。

  ```markdown
  原文：
  		这样的策略减少了当出现行移动或者数据也分裂时的二级索引的维护工作。使用主键值当作指针会让二级索引占用更多的空间。换来的好处是，InnoDB 在移动时无须更新二级索引中的这个指针。
  理解：
  		上面应该有一个前提，就是如果说二级索引的叶子节点存储的是行所在的"位置信息"。如果存储的是指针的话，在 C++ 里面，指针的大小是 4个字节，固定不变的。但是主键值可能不一定是整型，也可能是别的数据类型。因此可能会占用更多的空间。当需要进行页分裂的时候，则需要更新叶子节点中的位置信息，但是如果存的是主键值的话则不需要理会，因此省去了更新的开销。
  ```

+ InnoDB 的非叶子节点中包含了：**索引列** 和 **一个指向下级节点的指针**。

**在 InnoDB 表中按主键顺序插入行**

+ *最好的方式就是使用 auto_increment 自增列，这样可以保证数据行是按顺序写入，对于根据主键做关联操作的性能也会更好。*
  + **按照自增主键**，InnoDB 会吧每一条记录都存储在上一条记录的后面，当达到页的最大填充因此使(InnoDB 默认的最大填充因子使页大小的 15/16，留一部分的存储空间作更新使用。)
  + **按照随机主键,**  InnoDB 通常会插入到数据的中间位置，并且分配空间。(新数据之后的每条数据都要往后移)。这会增加很多额外的工作，导致数据分布不够优化。
+ 避免随机的(不连续的值、分布范围非常大)的主键，特别是对于 I/O 密集型的应用，使用 UUID 来作为聚簇索引就是非常糟糕的决定。这样会让数据没有任何聚集特性。并且索引的存储空间也会更大。还会使插入数据的耗时更长，一方面是由于主键字段更长，另一方面是由于页分裂和碎片导致的。

**随机主键的缺点：**

+ 写入的目标页可能已经刷到磁盘上并从缓存中移除，或者没有被加载到缓存中，InnoDB 在插入之前不得不先找到并从磁盘读取是目标页到内存中，这将会导致大量的 I/O。
+ InnoDB 会频繁地做页分裂的操作，以便为新行分配空间。页分裂会导致移动大量数据，一次插入最少需要修改三个页而不是一个页。
+ 频繁的页分裂会导致页变得稀疏，并被不规则地填充，所以最终数据会有碎片。

**顺序主键的缺点：**

+ 当出现高并发工作负载，在 InnoDB 中按照主键顺序插入可能会造成明显的争用，主键的上界会成为“热点”，所有的插入都发生在这里，所以并发插入可能导致间隙锁竞争。
+ 还有 auto_increment 锁机制。(这个目前不太了解)。

**总结**

​		InnoDB 应该尽可能低按照主键顺序插入数据，并且尽可能地使用单调增加的聚簇键的新值来插入新行。

### 5.3.6 覆盖索引

​		如果一个索引覆盖了所欲需要查询的字段的值，不需要进行回表，我们称为“覆盖索引”。当使用 explain 查看查询语句时，extra 的内容是 'using index' 意味着使用了覆盖索引。

**优点**

+ **索引条目通常远小于数据行的大小。** 1. 极大减少数据访问量。 2. 更容易将索引全部放在内存中，查询速度更快。3. 减轻缓存的负载，减少数据拷贝的压力。
+ **单个页内的索引按照列值顺序存储，随机 I/O 的次数更少。并且不需要回表。**
+ **MyISAM 只在内存中缓存索引，数据缓存依赖操作系统，因此访问数据需要进行一次系统调用，而系统调用开销极大。**
+ **对于 InnoDB 来说，使用了聚簇索引，因此如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询。**

**缺点**

+ 可能导致某些语句无法被优化。

  优化器回在执行查询前判断是否有一个索引能进行覆盖，假设索引覆盖了 where 条件中的字段，但不是整个查询涉及的字段，MySQL 页总是会回表获取数据行，尽管不需要这一行且最终会过滤掉。

  ```mysq
  -- possible keys: actor, ix_prod_actor
  -- key: actor
  explain 
  select * 
  from products 
  where actor='sean carrey' 
  	and title like '%APOLLO%'\G;
  ```

  缺点：

  + 没有任何索引可以覆盖这个查询，因为是 select *。因为没有任何索引覆盖了所有的列。
  + MySQL 不能在索引中执行 like 操作。MySQL 能在索引中做最做前缀匹配的 like 比较，因为该操作可以转换为简单的比较操作。但是如果通配符在前面，MySQL 服务器只能提取数据行的值而不是索引值来做比较了。

  解决：

  ```sql
  -- extra: using index; using where
  -- possible keys: actor, actor_2, ix_prod_actor
  -- key: actor_2
  
  explain
  select *
  from products
  join (
  	select prod_id
    from products
    where actor='sean carry' and title like '%APILLO%'
  ) as ti on (t1.prod_id = products.prod_id) \G;
  ```

  + 延迟关联(因为延迟了对列的访问)。在查询的第一阶段 MySQL 可以使用覆盖索引，在 from 子句的字查询中找到匹配的 prod_id，然后根据这些 prod_id 值在外层查询匹配或许需要的所有列值。虽然无法使用索引覆盖整个查询，但是总比完全无法利用覆盖索引的要好。
  + 如果说子查询返回的结果集太大，看不到优化的效果，大部分的时间都花在了读取和发送数据上。
  + 如果说字查询返回结果集很小，查询到来的成分反而比从表中直接提取完整行要更高。

### 5.3.7 使用索引扫描来做排序

​		MySQL 目前有两种方式可以生成有序的结果：**排序操作**，**按索引顺序扫描**。如果 explain 出来的 type 列的值为 index， 说明 MySQL 使用了索引扫描来做排序。扫描索引本身是很快的，因为只需要从一条索引记录移动到紧接着的下一条记录。但如果索引不能覆盖查询所需的全部列，就不得不每扫描一条索引记录，就回表查询一次对应的行。**这基本上都是随机 I/O, 因此按照索引顺序读取数据的速度通常比顺序地全表扫描要慢，尤其是在 I/O 密集型的工作负载时。**

​		**设计索引时应该尽可能满足，排序 和 查找行。**只要索引的列顺序和 order by 字句的顺序完全一致，并且所有列的排序方向也都一致，也就是说，要么全部都正序，要么全部都倒序，MySQL 才能使用索引来对结果做排。**如果查询需要关联多张表(顺带一提，关联的字段为同类型，同大小时，关联的效率更快)**，则只有当 order by 子句引用的字段全部为第一个表时，才能使用索引排序。

​		**order by 也要满足最做前缀的要求，除非，前导列为常量的时候，如果 where 子句或着 join 子句中对这些列指定了常量。**

```sql
create table rental(
	...
  primary key (rental_id),
  unique key rental_date (rental_date, inventory_id, customer_id),
  key idx_fk_inventory_id (inventory_id),
  key idx_fk_customer_id (customer_id),
  key idx_fk_staff_id (staff_id),
)
```

```sql
-- 因为索引的第一列被指定为了常数，所以使用了索引
explain select rental_id, staff_id
from rental
where rental_date = '2020-05-25'
order by inventory_id, customer_id \G;
```

+ `where rental_date > '2020-01-01' order by rental_date, inventory_id;` ( 使用 )

+ `where rental_date = '2020-01-01' order by inventory_id desc, customer_id asc;` ( 不同的排序方向 )

+ `where rental_date = '2020-01-01' order by inventory_id, staff-id;`( 用了一个不在索引中的列 )

+ `where rental_date = '2020-01-01' order by customer_id;` (where 和 order by 之间的字段无法组合成索引的最左前缀)

+ `where rental_date > '2020-01-01 order by inventory_id, customer_id;'` (where 子句里面不是常量)

+ `where rental_date > '2020-01-01 and inventory_id in (1, 2) order by customer_id;'` (in 也是范围查询)

+ ```sql
  explain select actor_id, title
  from film_actor
  inner join film using(film_id)
  order by actor_id \G;
  ```

  ```sql
  film -> using index;using temporary;using filesort
  film_actor -> using index
  ```

  理论上是可以使用索引进行关联排序的，但是优化器在优化的时候将 film_actor 表当作关联的第二张表，所以实际使用的时候是无法使用索引的。

### 5.3.8 前缀压缩索引

​		MyISAM 使用**前缀压缩**来减少索引的大小，从而让更多的索引可以放入内存中，**在某些情况下能极大地提高性能。** 默认只压缩字符串，但通过参数设置也可以对整数做压缩。

**MyISAM 压缩每个索引块的方法是：**

1. 先完全保存索引块中的第一个值
2. 将其他值和第一个值比较得到**相同前缀的字节数和剩余的不同后缀部分**，把这部分存储起来即可。

Example:

​		索引块的第一个值是'perform', 第二个值是'performance', 那么第二个值的前缀压缩后存储的是类似 '7,ance' 这样的形式。

​		MyISAM 对行指针也采用类似的前缀压缩方式。

**缺点：**

1. 查找时无法在索引块使用二分查找，只能从头开始扫描。正序的扫描速度不错，倒序就不好了。所有在块中查找某一行的操作平均都需要扫描半个索引块。(?)
2. 对于 CPU 密集型应用，因为扫描需要随机查找，压缩索引会更慢，压缩索引的倒序扫描就更慢了。压缩索引需要在 CPU 内存资源与磁盘之间做权衡，压缩索引可能只需要十分之一大小的磁盘空间，如果是 I/O 密集型应用，对某些查询带来的好处会比成本多很多。

### 5.3.9 冗余和重复索引

​		MySQL **允许在**相同列上创建多个索引。**重复**是指，在**相同的列上按照相同的顺序创建相同类型的索引。** **冗余** 是指，index(A,B) 和 index(A) 就是冗余索引。因为后者是前者的前缀索引，因此 index(A,B) 可以当作 index(A) 来使用的。如果再创建 index(B,A) 就不算冗余索引，index(B) 当然也不是。**这只针对 B-Tree来说。**

​		**在同一列上创建不同类型的索引来满足不同的查询需求，如 key(col1) 和 fulltest key(col1) 不算重复索引。**

Example1:

```sql
create table test(
	ID int not null primary key,
  A  int not null,
  B  int not null,
  unique(ID),
  index(ID)
) engine=InnoDB;
```

Example2:

​		有一个 index(A), 又有人加了一个 index(A, ID), 其中ID 是主键。对于 InnoDB 来说，主键列已经包含在二级索引中了，所以也是冗余的。

​		假如扩展已有的索引会导致其变得太大，从而影响其他使用该索引的查询的性能的话，应当另外考虑。大部分情况下都不需要冗余索引，应该尽量扩展已有的索引而不是创建新索引。

Example3:

​		假如在整数列上有一个索引，现在需要额外增加一个很长的 varchar 列来扩展该索引，性能可能会急剧下降。特别是假如有查询把这个索引当作覆盖索引，或者 MyISAM（前缀压缩）使用其做范围查询的时候。

Example4:

```sql
-- 在 userinfo 表上有一个 index(state_id)
-- 查询执行速度 115 QPS
select count(*) from userinfo where state_id = 5;

-- 不到 10 QPS
select state_id, city, address from userinfo where state_id=5;

-- 扩展索引为 (state_id, city, address) 使其能使用覆盖索引
alter table userinfo drop key state_id, add key state_id_2(state_id, city, address);

-- 这样以后虽然 Q2 是快了，但是 Q1 却慢了，这时候就还是需要加上 index(state_id) 了。这对 InnoDB 来说并不明显，对 MyISAM 来说却是非常明显的。但是加上两个索引的缺点就是索引成本会更高，插入更新和删除的时候当然就会变慢了。
```

**解决冗余索引和重复索引的方式就是删除他们。**

### 5.3.10 未使用的索引

​		在 Percona Server 或者 MariaDB 中打开 userstates 服务器变量，默认是关闭的，然后让服务器正常运行一段时间，再通过查询 INFOMATION_SCHEMA.INDEX_STATISTICS 就能查到每个索引的使用频率。对于未使用过的索引，应该进行删除。

### 5.3.11 索引和锁

​		索引可以让查询锁定更少的行, 而 InnoDB 只有在访问行的时候才会对其加锁。索引可以减少 InnoDB 访问的行数，**只有当 InnoDB 在存储引擎层能够过滤掉所有不需要的行时才有效。** 如果索引无法过滤掉无效的行，那么 InnoDB 检索到数据返回再返回给服务器层以后，MySQL 服务器才能应用 WHERE 子句，**这时就已经无法避免锁定行了。**

​		在 MySQl 5.1+, InnoDB 可以在服务器端过滤掉行以后就释放锁。

​		在早期的版本中，InnoDB 只有在事务提交后才能释放锁。

Example:

```sql
SER AUTOCOMMIT=0;
BEGIN;
SELECT actor_id FROM actor WHERE actor_id < 5 AND actor_id <> 1 
FOR UPDATE;
```

​		[先看下什么是 FOR UPDATE](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking-reads.html) 、[另一篇笔记]()

​		这条查询仅仅会返回 2 ～ 4 之间的行，但是实际上获取了 1 ～ 4 之间的行的排他锁。InnoDB 会锁住第一行，这是因为 MySQL 为该查询选择的执行计划是索引范围扫描。

```sql
EXAMPLE SELECT actor_id FROM actor WHERE actor_id < 5 AND actor_id <> 1 FOR UPDATE;
```

```sql
type: range | key: primary | extra: using where; using index
```

​		底层存储引擎的操作是：从索引的开头开始获取满足条件 actor_id < 5 的记录，但是并没有过滤 actor <> 1 的条件。extra 中的 using where 就表示 MySQL 服务器将存储引擎返回的行上应用了 where 过滤条件。

```sql
SET AUTOCOMMIT=0;
BEGIN;
SELECT actor_id FROM actor WHERE actor_id = 1 FOR UPDATE;
```

​		这个查询将会**挂起**，直到第一个事务释放第一行的锁。可以用上面这条来验证 actor_id = 1 的行被加上行锁。

​		因此即使使用索引，还是可能导致 InnoDB 锁住一些不需要的数据，如果不能使用索引查找和锁定行的问题可能更糟糕，MySQL 会做全表扫描，并锁住所有的行，不管是不是需要。

​		**InnoDB 在二级索引上使用共享锁，但访问主键索引需要排他锁，这消除了使用覆盖索引的可能性，并且使得 select for update 比 lock in share mode 或非锁定查询要慢得多。**

## 5.4 索引案例学习(这里貌似涉及到版本问题，务必查看最新文档)

​		假设要设计一个在线约会网站，用户信息表有很多列，包括国家、地区、城市、性别、眼睛颜色等等。网站必须支持上面这些特征的各种组合来搜索用户，还必须允许根据用户的最后在线时间，其它会员对用户的评分等，对用户进行*排序*并对结果进行*限制*。**如何设计索引来满足上面的复杂需求呢？**

​		**第一，考虑是否需要使用索引来排序，还是先检索数据再排序。** 如果使用了其它会员对用户评分的排序，则 where age between 18 and 25 就无法使用索引。这是常见的 where 条件，因此有很多查询都需要做排序操作。

### 5.4.1 支持多种过滤条件

​		**看看哪些列拥有很多不同的取值，哪些列在 WHERE 子句中出现的最频繁。** 在有很多不同取值的列上创建索引更好，因为可以让 MySQL 过滤掉不需要的行。

​		country 列的选择性通常不高，sex 列的选择性肯定很低，但也会在很多查询中用到。**考虑使用频率，建议在创建不同组合索引的时候将 (sex, country) 作为前缀。**

+ sex 列的使用频率非常之高。几乎每一条搜索都会用到。
+ 即使没有用到，也可以在查询条件中新增 `AND sex IN ('m', 'f')` 来让 MySQL 选择该索引。这样写虽然不会过滤任何行，和没有这个条件返回的结果也都一致。但是满足索引的最左前缀，使用创建的索引。**如果创建某些索引会降低另一些查询的效率，也可以从优化另一些查询上入手，而不是纠结于创建完美索引。**

*(sex, country, age)、(sex, country, region, age)、(sex, country, region, city, age) 这些都是可能创建的索引。但是这样需要大量索引，如果想要尽可能重用索引，可以借鉴前面的 `IN` 的方法。*

​		**还存在一些生僻的搜索条件如：has_picture、eye_color、hair_color、education**。

+ 这些列的选择性通常较高，使用也不频繁，可以选择忽略，让 MySQL 多扫描一些额外的行即可。
+ **考虑涉及到 age 列的查询多是范围查找，** 而查询只能使用索引的最左前缀，知道遇到第一个范围条件列。还可以将生僻列放在 age 列的前面创建索引，在查询中同样使用 `IN` 的大招即可。(??但其实用了范围查找也是能用索引的，没懂)

！！！！ 每额外增加一个 IN 条件，优化器需要做的组合都在以指数形式增加，最终可能极大地降低查询性能。

```sql
WHERE eye_color IN ('brown', 'blue', 'hazel')
	AND hair_color IN ('black', 'read', 'blonde', 'brown')
	AND sex IN ('m', 'f');
```

优化器会将上面的情况转换成 4 * 3 * 2 = 24 中组合，**也就是说执行需要检查 where 子句中所有的 24 种组合。如果过于多的话会消耗大量的内存。**

### 5.4.2 避免多个范围条件

​		EXPLAIN 会把 `IN`  和 `<` 、`>` 都当作 type=range 类型来处理。而使用 `IN` 相当于多个等值条件查询。这两种访问效率是不同的，对于范围条件查询，MySQL 无法再使用范围列后面的其它索引列了，但是对于"多个等值条件查询" 则没有这个限制。

```sql
WHERE eye_color IN ('brown', 'blue', 'hazel')
	AND hair_color IN ('black', 'read', 'blonde', 'brown')
	AND sex IN ('m', 'f')
	AND last_online > DATE_SUB(NOW(), INTERVAL 7 DAY)
	AND age BETWEEN 18 AND 25;
```

​		这里有两个范围条件，last_online 和 age, MySQL 可以使用 last_online 索引 或者 age 索引。但是无法同时使用他们。（这里 MySQL 5.7.28 也是同样的表现形式）。如果我们无法把 age 字段转换成 IN() 的列表，并且仍要求对于同时有 last_online 和 age 两个字段的范围查询，且速度很快，**这是无法达到的**。

​		**但是我们能够将其中的一个范围查询转换为一个比较简单的等值查询，比如要查最近七天的数据，可以额外计算一个 atcive 字段，近7天登录过的字段为1。这样就可以使用 (active, sexm country, age) 的索引。**

​		如果未来版本的 MySQL 能够实现松散索引扫描，能在一个索引上使用多个范围条件，也就不需要为上面这些查询考虑 IN 了。

### 5.4.3 优化排序

​		对于选择性非常低的列，可以增加一些特殊的索引来做排序。如(sex, rating)。当遇到 order by 和 limit 同时存在的情况下，随着偏移量的增加，MySQL 需要花费大量的时间来扫描需要丢弃的数据。**反范式化、预先计算、缓存 可能是解决这类查询仅有的策略。** 当然也可以限制用户能够翻页的数量，因为很少有用户在乎搜索结果的第 10000 页。

```sql
SELECT <cols>
FROM profiles
INNER JOIN (
	SELECT <primary key cols> 
  FROM profiles
  WHERE x.sex='M' ORDER BY rating LIMIT 20000, 10
) AS x
USING (<primary key cols>);
```

## 5.5 维护索引和表

暂不做记录。

## 5.6 总结

在选择索引和编写利用这些索引的查询时，有如下三个原则始终需要记住。

1. **单行访问是很慢的**。特别是在机械硬盘存储中，如果服务器从存储中读取一个数据块只是为了获取其中一行，那么就浪费了很多工作。最好读取的块中尽可能包含所需要的行。而使用索引可以创建位置引用以提升效率。
2. **按顺序访问数据是很快的。** 第一，顺序 I/O 不需要多次磁盘寻道，所以比随机 I/O 要快很多(特别是对于机械硬盘来说)。第二，如果服务器能够按需要顺序读取数据，那么就不在需要额外的排序操作，GROUP BY 查询也无需再做排序和将行按组进行聚合计算了。
3. **索引覆盖查询是很快的。** 如果一个索引包含了查询所需要的所有列，那么存储引擎就不需要再回表查找行。这样避免了大量的单行访问。

**总之～，** 编写查询语句时应该尽可能选择可是的索引以避免单行查找，尽可能使用数据的原生顺序从而避免额外的排序操作，并且尽可能使用索引覆盖查询。

按响应时间来对索引的合理性进行分析。找出消耗最长时间的查询，或者是那些给服务器带来最大压力的查询，然后检查这些 schema、SQL 和 索引结构，判断**是否有查询扫描了太多的行**，**是否做了很多额外的排序**，**是否使用了临时表**，**是否使用随机 I/O 访问数据**，**是否有太多的回表查询**。

















































