# 面试题：InnoDB 中唯一索引 和 普通索引 的选择？

#### 1. 唯一索引 和 普通索引 概念上的区别？

```markdown
1. 唯一索引不允许有重复值，可以为空
2. 普通索引允许有重复值，可以为空
```

#### 2. 唯一索引 和 普通索引 在查询过程上的比较

```markdown
唯一索引：在数据页中找到第一个满足条件的记录后，就会停止检查
普通检查：在数据页中找到第一个满足条件的记录后，还会继续检查，直到遇到第一个不满足的记录
```

#### 3. 唯一索引 和 普通索引 在查询性能上的比较

```markdown
结论：差不多
原因：
InnoDB 中的读一条记录是把那条记录所在的磁盘页一起读进内存的。对于普通索引来说也就多几次的 (指针查找 && 一次计算)。除非说下一条刚好在下一个磁盘页上，那操作会稍微复杂一些。
```

#### 4. 唯一索引 和 普通索引 在更新性能上的比较

**InnoDB 对于更新做了优化 - Change Buffer**

```markdown
原理：
- 如果数据页此时在内存中：
    1. 就直接修改内存。
- 如果数据也不在内存中：
    1. 在不影响数据一致性的前提下，InnoDB 会将这些更新操作缓存在 change buffer 中，这样就不需要从磁盘中读取这个页了。
    2. 下次需要访问这个数据页的时候，将数据页读入内存，然后执行 change buffer 中和这个页有关的操作。
    3. change buffer 是可以持久化的数据，除了访问这个内存页的时候会触发 merge(将 change buffer 中的更改应用到数据页上的行为)，后台线程也会定期 merge, 当数据库进行正常关闭也会执行 merge 操作。

应用场景：
    1. 适用于需要频繁修改，但是不会马上访问。比如账单类、日志类。
    (减少读磁盘的次数，避免数据读入内存，提高了内存利用率)
```

**比较**

```markdown
唯一索引：
1. 所有的更新操作都要先判断这个操作是否违反了唯一性约束。因此必须要先把数据读入内存才可以。如果数据都已经在内存了，直接改内存就好了，不需要用到 change buffer。因此唯一索引是无法利用 change buffer 的。

普通索引：
1. 通常使用 change buffer 进行更新。

结论：
如果所有的更新后面都伴随这对这条记录的查询，应该关闭 change buffer。其它情况应该打开 change buffer。普通索引 + change buffer 对更新表的性能优化较为明显。
```


