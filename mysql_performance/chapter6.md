# 章六：查询性能优化

## 6.1 为什么查询速度会慢

​       如果把查询看成一个任务，那么它由一系列子任务组成。要查看有哪些子任务，有以下几种方法，

+ **捕获 MySQL 的查询到日志文件中**

  通过设置 long_query_time = 0 来捕获所有的查询，慢查询日志是开销最低、精度最高的测量查询时间的工具，其带来的开销可以忽略不计，但是会消耗大量的磁盘空间。

+ **分析查询日志**

  应当先从慢查询中生成剖析报告(建议使用 pt-query-digest， 可以将报告保存到数据库中，以及追踪工作负载随时间的变化)。

+ **剖析单条查询 show status、show profile**

  会给出查询执行的每个步骤及其花费的时间。具体的使用不做详述。

通常来说，查询的生命周期大致可以按照顺序来看：从客户端，到服务器，然后在服务器上进行解析，生成执行计划，执行，并将结果返回给客户端。其中"执行"可以认为是整个生命周期中最重要的阶段，这其中包括了大量为了检索数据到存储引擎的调用以及调用后的数据处理，包括排序、分组等。

## 6.2 慢查询基础：优化数据访问

​		查询性能低下的**最基本的原因**就是访问的数据太多。发部分性能低下的查询都可以**通过减少访问的数据量的方式**进行优化。

对于低效的查询可以通过下面两个步骤来分析：

1. 确认应用程序时都在检索大量超过需要的数据。(可能是访问了太多的行、列)。
2. 确认 MySQL 服务器层是否在分析大量超过需要的数据行。

### 6.2.1 是否向数据库请求了不需要的数据

​		有些查询会请求超过实际需要的数据，然后这些多余的数据会被应用程序丢弃。这会给 MySQL 服务器带来额外的负担，并且增加网络开销，另外也会消耗应用服务器的 CPU 和内存资源。

+ *典型案例：*

**查询不需要的记录**

​		**一个常见的错误**是常常会误以为 MySQL 会只返回需要的数据。实际上 MySQL 是先返回全部结果集再做计算。(先使用 SELECT 语句查询大量的结果，然后获取前面的 N 行后关闭结果集，比如需要分页的情况，这种时候就要使用 LIMIT 了)。

**多表关联时返回全部列**

​		应当只取回需要的列，而不是返回全部的列。

```sql
SELECT *
FROM actor 
INNER JOIN film_actor USING(actor_id)
INNER JOIN film USING(film_id)
WHERE film.title = 'Line Walker';
```

**总是取出全部列**

​		取出全部列，会让优化器无法完成覆盖索引扫描这类优化，还会为服务器带来额外的 I/O、内存、CPU 的消耗。虽然这样做可能能避免列被修改带来的问题，简化开发，提高相同代码的复用性。如果有缓存的话，获取超过需要的数据可能也有其好处。

**重复查询相同的数据**

​		例如，在用户评论的地方需要查询用户头像的 URL，当用户多次评论的时候可能会反复查询这个数据。不如在初次查询的时候将这个数据缓存起来。

### 6.2.2 MySQL 是否在扫描额外的记录

以下三个指标都会被记录到 MySQL 的慢日志中，所以检查慢日志记录时找出扫描行数过多的查询的好方法。

+ 响应时间
+ 扫描的行数
+ 返回的行数

#### 响应时间

​		响应时间是两部分之和：服务时间和排队时间。**服务时间**：是指数据库处理这个查询真正花了多长时间。**排队时间**：是指服务器因为等待某些资源而没有真正执行查询的时间，可能是等 I/O 操作完成。也可能是等待行锁，等等。**首先判断响应时间的上限**：*Relational Database Index Design and the Optimizers* 一书中提到计算方式，大概是了解这个查询需要哪些索引以及它的执行计划是什么，计算大概需要多少个顺序和随机 I/O，在用其乘以在具体硬件条件下一次 I/O 的消耗时间，最后把这些消耗加起来，就可以判断当前的响应时间是否是一个合理的值了。

#### 扫描的行数和返回的行数

​		理想状态下，扫描的行数 和 返回的行数 应该是**相同的**。但是实际情况中这样的“美事”并不多，例如在做一个关联查询时，服务器必须要扫描多行才能生成结果集中的一行。扫描的行数对返回的行数的比率通常很小，一般在 1:1 和 10:1 之间。

#### 扫描的行数和访问类型

​		EXPLAIN 语句中的 **type** 列反应了 **访问类型**。访问类型有：全表扫描 > 索引扫描 > 唯一索引扫描 > 常数引用等(时间由慢到快)。不需要记住访问类型，但需要明白扫描表、扫描索引、范围访问、单值访问的概念。

​		Extra = Using Where 表示 MySQL 将通过 WHERE 条件来筛选存储引擎返回的数据。

**一般 MySQL 能够使用如下三种方式应用 WHERE 条件，从好到坏依次为：**

+ **在索引中使用 WHERE 条件来过滤不匹配的记录**，这是在存储引擎层完成的。

+ 使用覆盖索引扫描(Extra = Using Index) 来返回记录的，这是在服务器层完成的，无须回表查询。
+ 从数据表中返回数据，然后过滤不满足条件的记录(Extra = Using Where), 这是在 MySQL 服务器层完成的。

**如果发现查询需要扫描大量的数据但只返回少数的行，可以通过下列技巧优化：**

+ 使用索引覆盖扫描，把所有需要用的列放在索引中。
+ 改表结构。比如：使用单独的汇总表。
+ 重写复杂查询，使得 MySQL 优化器能够以更优化的方式执行。

## 6.3 重构查询的方式

### 6.3.1 一个复杂查询还是多个简单查询

设计查询时需要考虑的一个**重要问题**是，是否需要将一个复杂查询分成多个简单查询。*MySQL 从设计上让连接和断开连接都很轻量级*，在返回一个小的查询结果方面很高效。即使在一个通用服务器上，也能够运行**每秒超过10万的查询**。而 MySQL 内部每秒能扫描内存中上百万行数据，相比之下，MySQL 响应数据给客户端就慢得多了。

### 6.3.2 切分查询

举个栗子：删除大量旧的数据。一次删除可能 **需要锁住很多数据**、**占满整个事务日志**、**耗尽系统资源**、**阻塞很多小却重要的查询**。分批删除可以 **尽可能小的影响 MySQL 性能**，**减少 MySQL 复制的延迟**，**减少删除时对锁的持有时间**。

### 6.3.3 分解关联查询

```sql
SELECT *
FROM tag
JOIN tag_post ON tag_post.tag_id = tag.id
JOIN post ON tag_post_id = post.id
WHERE tag.tag = 'mysql';
```

```sql
SELECT * FROM tag WHERE tag='mysql';
SELECT * FROM tag_post WHERE tag_id=1234;
SELECT * FROM post WHERE post.id in (123, 456, 567, 9098, 8904);
```

**优势：**

+ 让缓存的效率更高。 **对于 MySQL 的查询缓存来说，如果关联中的某个表发生了变化，就无法使用查询缓存了，拆分后如果某个表很少改变，基于该表的查询就可以重复利用查询缓存的结果了。**
+ 执行单个查询可以减少锁竞争。
+ 在应用层做关联，可以更容易对数据库进行拆分。
+ 查询本身的效率可能提升，顺序查询比随机关联更高效。
+ 减少冗余数据的查询，在应用层做关联查询，意味着对于某条记录应用只需要查询一次，而在数据库中做关联查询，则可能需要重复地访问一部分数据。(还能减少网络和内存的消耗)。
+ 相当于在应用中实现了哈希关联，而不是使用 MySQL 的嵌套循环关联。

## 6.4 查询执行的基础

客服端 -> 一条查询 -> MySQL 服务器 -> 检查缓存，命中则返回结果 -> SQL 解析器 -> 预处理器 -> 优化器生成执行计划 -> 调用存储引擎 API 执行查询语句 -> 将结果返回给客服端。

### 6.4.1 MySQL 客户端/服务器 通信协议

​		通信协议是 **“半双工”** 的，意味着在任何一个时刻，要么由服务器向客户端发送数据，要么由客户端向服务器发送数据，两者不可同时发生。所以也无须将一个消息切成小块来独立发送。**一个明显的限制是：** 意味着无法进行流量控制。一旦一端开始发送消息，另一端要接收完整的消息以后才能响应它。

​		**对于客户端来说，**当查询语句很长，max_allowed_packet 就特别重要。如果过大，服务端会拒接接收更多的数据并抛出相应的错误。

​		**对于服务端来说，** 一般服务器响应给用户的数据通常很多，由多个数据包组成。**一旦服务器开始响应请求，客户端必须完整地接收整个返回结果**，而不能简单地只取前面几条结果，然后就断开连接。这也是在必要的时候一定要在查询中加上 LIMIT 的原因。

​		**多数连接 MySQL 的库函数都可以获得全部结果集并缓存到内存里，还可以逐行获取需要的数据。** 一般是获得全部结果集然后缓存到内存中。MySQL 通常要等到所有的数据都已发送给客户端才能释放这条查询所占有的资源。所以接受全部结果并缓存通常可以减少服务器的压力。因此当返回结果过大时，可以关掉缓存，尽快处理掉返回的数据，MySQL 服务端才能尽快释放掉相应的资源。

#### 查询状态

`SHOW FULL PROCESSLIST` 返回的 COMMAND 列就表示当前状态。

+ *Sleep* - 线程正在等待客服端发送新的请求
+ *Query* - 线程正在执行查询或者正在将结果发送给客户端
+ *Locked* - 在服务器层，该线程正在等待表锁。在存储引擎级别实现的锁，例如 InnoDB 中的行锁是不会体现在线程状态中的
+ *Analyzing and statistics* - 线程正在搜集存储引擎统计的信息，并生成查询的执行计划
+ *Copying to tmp table [on disk]* - 正在执行查询，并且将结果集都复制到一张临时表中，这种状态一般要么是在做 group by, 要么是文件排序，要么是 union. on disk 表示 MySQL 正在将一个内存临时表放到磁盘上
+ *Sorting result* - 线程正在对结果集进行排序
+ *Sending data* - 表示多种情况，可能在多个状态之间传送数据，或者生成结果集，或者在想客户端返回数据。
+ *Statistics* - 正在占有大量时间，通常表示某个地方有异常了。

### 6.4.2 查询缓存

​		如果查询缓存是打开的，优先检查这个查询是否命中查询缓存中的数据。**这个检查是通过一个对大小写敏感的哈希查找实现的。**如果命中，MySQL 会检查一次用户权限，没问题再直接将结果返回给客户端。

### 6.4.3 查询优化处理

#### 语法解析器 和 预处理

+ 语法解析器

  通过关键字将 SQL 语句进行解析，生产一棵对应的 “解析树”。MySQL 解析器将使用 MySQL 语法规则验证和解析查询。

+ 预处理器

  预处理器根据一些 MySQL 规则进一步检查解析树是否合法，例如，这里将检查数据表和数据列是否存在，还会解析名字和别名，看看它们是否有歧义。再去验证权限。

#### 查询优化器

​		将语法树转换成执行计划。MySQL 使用基于成本的优化器。它尝试预测一个查询使用某种执行计划时的成本，选择最小的。可以通过查询当前会话的 Last_query_cost 的值得知 MySQL 计算的当前查询的成本。

`SELECT SQL_NO_CACHE COUNT(*) FROM film_actor;`

`SHOW STATUS LIKE ‘Last_query_cost’;  -- value = 1040.599000 表示大概要做 1040 个数据页的随机查找才能完成上面的查询。`

**优化策略**

+ 静态优化

  **和查询的上下文无关**， 直接对解析树进行分析，并完成优化。例如：优化器可以通过一些简单的代数变换将 WHERE 条件转换成另一种等价形式。并且和查询时代入的一些常数无关，第一次完成以后一直有效，可以认为是一种 "编译时优化"。

+ **动态优化**

  **和查询的上下文有关**，也可能和很多其它因素有关，例如 WHERE 条件中的取值、索引中条目对应的数据行数等。这需要在每次查询的时候都进行重新评估，可以认为是 "运行时优化"。有时甚至在查询执行的过程中也会重新优化。
  

**MySQL 可处理的优化类型：**

+ 重新定义关联表的顺序
+ 将外连接转换为内连接
+ 使用等价变换规则（合并和减少一些比较，移除一些恒成立和一些恒不成立的判断）
  + (5==5 and a>5) 改写为 a>5
  + (a<b and b=c) and a=5 改写为 b>5 and b=c and a=5
+ **优化 count()、min()、max()**
  + 索引和列是否可为空通常可以帮助 MySQL 优化这类表达式。
    + 如果要找到最小值，只需要找 B-Tree 索引最左端的记录，MySQL 可以直接获取索引的第一行记录。在 B-Tree 索引中，优化器会将这个表达式作为一个常数对待。如果在 EXPLAIN 中看到 "select tables optimized away" ，则表示优化器已经从执行计划中移除了该表，并以一个常数取而代之。

+ **预估并转化为常数表达式**

  + 当 MySQL 检测到一个表达式可以转化为常数的时候，就会一直把该表达式作为常数进行优化处理。甚至在优化阶段，甚至一个查询也能够转化为一个常数。

    ```sql
    EXPLAIN SELECT film.film_id, film_actor.actor_id
    FROM film
    	INNER JOIN film_actor USING(film_id)
    WHERE film.film_id = 1;
    ```

    + type: const / ref: const - MySQL 第一步先从 film 表找到需要的行，因为在 film_id 字段上有主键索引，所以 MySQL 优化器知道这只会返回一行数据。因为优化器已经明确知道有多少个值(WHERE 条件中的值) 需要做索引查询，所以这里的表访问类型是 const。
    + type: ref / ref: const - MySQL 将第一步中返回的 film_id 列当作一个已知取值的列来处理。因为优化器清楚在第一步执行完成后，这个值就是明确的了。也就是说其实 优化器知道 film_id 即使用在 using 里面也始终是一个常数值。

+ 覆盖索引扫描

  + 当索引中的列包含所有查询中需要使用的列时，MySQL 就可以使用索引返回需要的数据，而无须查询对应的数据行。

+ 子查询优化

  + MySQL 在某些情况下可以将子查询转换为一种效率更高的形式，从而减少多个查询多次对数据进行访问。

+ 提前终止查询

  + 在发现已经满足查询需求时，MySQL 总能立刻终止查询。比如：LIMIT 子句的使用。发现了一个不成立的条件则立刻返回空。

    ```sql
    EXPLAIN SELECT film_id FROM film WHERE film_id = -1;
    ```

+ 等值传播

  + 如果两个列的值通过等式关联，那么 MySQL 能够把其中一个列的 WHERE 条件传递到另一列上。这个在常数替换的栗子中已经有所体现了。

+ **列表 IN() 的比较**

  + MySQL 中对于 OR 来说，遍历全表是 O(N), 然后将每一行数据都和 WHERE 条件中的每一个条件做比较，还是 O(N)
  + MySQL 中对于 IN 来说，遍历全表是 O(N), 然后将 IN() 列表中的数据进行排序，将每一行数据与 IN() 中的数据进行二分查找，所以时间复杂度是 O(logN)


#### 数据和索引的统计信息

​		在服务器层有查询优化器，却没有保存数据和索引的统计信息。统计信息由存储引擎实现，不同的存储引擎可能会存储不同的统计信息。有些引擎甚至都不存储任何的统计信息。**MySQL 查询优化器在生成执行计划的时候，需要向存储引擎获取相应的统计信息。**统计信息包括有，每个表或者索引有多少个页面，每个表的每个索引的基数是多少、数据行 和 索引长度、索引的分布信息等等。

#### MySQL 如何执行关联查询

​		**不单单是多表查询才叫关联查询。**先看 Union 查询，MySQL 先将一系列的单个查询结果放到一个临时表中，然后再重新读出临时表数据来完成 Union 查询。

​		**当前 MySQL 关联执行的策略很简单：** MySQL 对任何关联都执行嵌套循环关联操作，即 MySQL 先在一个表中循环取出单条数据，然后再循环嵌套到下一张表中寻找匹配的行，依次下去，直到找到所有表中匹配的行位置。MySQL 会尝试在最后一个关联表中找到所有匹配的行，如果最后一个关联表无法找到更多的行，就返回上一层次的关联表，看是否能找到更多的匹配记录，依次类推迭代执行。**也就是一种深度优先的方式遍历的。**

```sql
SELECT col1, col2
FROM tbl1
INNER JOIN tbl2 USING(col3)
WHERE tbl1.col1 IN(5, 6);
```

+ outer_iter = iterator over tbl1 where col1 IN (5, 6)

+ outer_row = outer_iter.next

+ while outer_row

  ​		inner_iter = iterator over tbl2 where col3 = outer_row.col3

  ​		inner_row = inner_iter.next

  ​		while inner_row

  ​				output [outer_row.col1, inner_row.col2]

  ​				inner_row = inner_iter.next

  ​		end

  ​		outer_row = outer_iter.next

  end

```sql
SELECT col1, col2
FROM tbl1
LEFT OUTER JOIN tbl2 USING(col3)
WHERE tbl1.col1 IN(5, 6);
```

+ outer_iter = iterator over tbl1 where col1 IN (5, 6)

+ outer_row = outer_iter.next

+ while outer_row

  ​		inner_iter = iterator over tbl2 where col3 = outer_row.col3

  ​		inner_row = inner_iter.next

  ​		**if inner_row**

  ​				while inner_row

  ​						output [outer_row.col1, inner_row.col2]

  ​						inner_row = inner_iter.next

  ​				end

  ​		**else**

  ​				**output [ outer_row.col1, NULL ]**

  ​		**end**

  ​		outer_row = outer_iter.next

  end

**全外连接** 就无法通过嵌套循环和回溯的方式完成。

#### 执行计划

​		MySQL 并不会生成查询字节码来执行查询，而是生成一棵查询的指令树，然后通过存储引擎来完成这个指令树并返回结果。最终的执行计划包含了重构查询的全部信息，**如果对某个查询执行 EXPLAIN EXTENDED 后，再执行 SHOW WARNINGS, 就可以看到重构出的查询了。** 这是一棵平衡树，这是一棵左侧深度优先的树。

![语法树](/Users/caiqingjing/Downloads/未命名文件.png)

#### 关联查询优化器

优化器**最重要的一部分**就是关联查询优化，它决定了多个表关联时的顺序。

```sql
SELECT film.film_id, film.title, actor.actor_id, actor.first_name, actor.last_name
FROM film
INNER JOIN film_actor USING(film_id)
INNER JOIN actor USING(actor_id);
```

##### 执行计划 1

将 film 作为第一个关联表时，会找到 951 条记录，然后对 film_actor 和 actor 表进行嵌套循环查询。

##### 执行计划 2

将 actor 作为一个关联表时，只会返回 200 条记录进行后面的嵌套循环查询。

**假如说你认为你的执行计划更精准，可以用 STRAIGHT_JOIN 关键字重写查询。** 通常来说，优化器会将所有关联表的顺序都评估一遍，生成一棵执行树，然后选择成本最小的。但是当关联表的数量超过一定的数量时，比如10张表，那就会有 （10 * 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2 * 1）种情况，优化器不可能所有的情况都评估过，因此会采用 ”贪婪“ 搜索方式。所以偶尔也会有优化不准的时候出现。

#### 排序优化

​		排序是一个成本很高的操作，无论如何都应该避免。如果不能使用索引排序的话就要 MySQL 自己排序，数据量小就在内存中进行，大的话则需要使用磁盘，这个过程统一称为 文件排序(filesort)。

​		**如果需要排序的数据量小于 “排序缓冲区”，MySQL 则使用内存进行快排。如果内存不够，就先将数据分块，然后逐个进行快排，最后 merge 起来。**

##### MySQL 有如下两种排序算法

+ **两次传输排序（旧版本）**

​		读取行指针和需要排序的字段，对其进行排序，然后再根据排序结果读取所需要的数据行。这需要进行两次数据传输，即需要从数据表中读取两次数据，第二次读取数据的时候，因为是读取排序列进行排序后的所有记录，这回产生大量的随机 I/O，所以两次数据传输的成本非常高。

+ **单次传输排序（新版本）**

  先读取查询所需要的所有列，再根据给定列进行排序，最后直接返回排序结果。

  + 优点：这个算法只需要一次顺序 I/O 读取所有的数据，无须任何的随机 I/O。
  + 缺点：**1.** 如果返回的列非常多，非常大，会额外占用大量的空间，而这些列对排序操作的本身是没有任何作用的。**2. **可能会有更多的排序快需要合并。

##### 关于临时存储空间(临时表空间可能会比磁盘上的原表大很多倍)

+ 为每一个排序记录预留足够的定长空间来存放。
  + varchar 则分配其完整长度
  + UTF-8 字符集则为每个字符都预留三个字节 

##### 关于关联查询

+ 如果 order by 子句中的所有列都来自关联的第一个表
  + MySQL 在关联处理第一个表的时候就进行文件排序。explain 的时候会看到 Using filesort
+ 除上面的情况之外
  + 先将关联的结构都存放到一个临时表中，然后在所有的关联结束以后再进行排序。explain 的时候会看到 Using temporary; Using filesort。

### 6.4.4 查询执行引擎

​		MySQL 只是简单地根据执行计划给出的指令逐步执行。在根据执行计划逐步执行的过程中，有大量的操作需要通过调用存储引擎实现的接口来完成。**查询中每个表由一个 handler 的实例来表示。在优化器优化阶段就会被生成，和表相关的信息都由 handler 来获得**存储引擎的底层接口只有十几个，这些接口互相组合能完成查询的大部分操作。

### 6.4.5 返回结果给客户端

​		MySQL 将结果集返回给客户端是一个增量、逐步返回的过程。例如，一旦服务器处理完最后一个关联表，开始生成第一条结果时，MySQL 就可以开始向客户端逐步返回结果集了。结果集中的每一行都会以一个满足 MySQL 客户端/服务器 通信协议的封包发送，再通过 TCP 协议进行传输，在传输过程中可能会对 MySQL 的封包进行缓存然后批量传输。

+ **优点**
  + 服务端无须存储太多的结果，不需要消耗太多的内存。
  + 可以让客户端第一时间就获得返回的结果。

## 6.5 MySQL 查询优化器的局限性

### 6.5.1 关联子查询

```sql
SELECT *
FROM film
WHERE film_id IN (
	SELECT film_id
  FROM film_actor
  WHERE actor_id = 1
);
```

​		通常认为是先查出 IN() 里面子查询的语句，然后执行外层查询语句

​		**实际上 MySQL 会将其改写成：(可以使用 explain extended 来查看这个查询被改写成啥样, 实际上也并没有结果)**

```sql
SELECT *
FROM film
WHERE EXISTS (
	SELECT *
  FROM film_actor
  WHERE actor_id AND film_actor.film_id = film.film_id
);
```

​		这里会先对 film 进行全表扫描，然后拿出每一条 film_id 去关联 film_actor.film_id, 等于说又对 film_actor 进行一遍全表扫描。如果说外层表是一个非常大的表，查询性能就会非常糟糕。

```sql
SELECT film.*
FROM film
INNER JOIN film_actor USING(film_id)
WHERE actor_id = 1;
```

另一个优化方法是使用函数 GROUP_CONCAT() 在 IN() 中构造一个由逗号分隔的列表。有时这会比上面使用的 IN() + 子查询，性能更好。通常建议 EXISTS() 等效地高些查询来获得更好的效率。

##### 如何用好关联子查询

```sql
EXPLAIN SELECT film_id, language_id
FROM film
WHERE NOT EXISTS(
	SELECT *
  FROM film_actor
  WHERE film_actor.film_id = film.film_id
);
```

一般会建议使用 LEFT OUTER JOIN 重写该查询，以代替子查询。理论上 MySQL 的执行计划不会发生改变。

```sql
EXPLAIN SELECT film.film_id, film.language_id
FROM film
LEFT OUTER JOIN film_actor USING(film_id)
WHERE film_actor.film_id IS NULL;
```

balabala 说了一堆，没看懂，暂时不记录了。**结论就是：使用子查询的写法会略微慢些。** 作者始终强调的是 **应该通过测试来验证猜想，而不要主观猜测。**

### 6.5.2 UNION 的限制

​		如果希望 UNION 的各个子句能够根据 LIMIT 只取部分结果集，或者希望能够先排好序再合并结果集的话，就需要再 UNION 的各个子句中分别使用这些字句。例如，想将两个子查询结果联合起来，再取前 20 条记录，那么 MySQL 会将两个表都存放到同一个临时表中。然后再取出前 20 行数据。另外需要注意的一点是：**从临时表中取出的顺序并不一定，还需要在全局加上一个 order by.**

### 6.5.3 索引合并优化

​		当 WHERE 字句中包含多个复杂条件的时候，MySQL 能够访问单个表的多个索引以合并和交叉过滤的方式来定位需要查找的行。

### 6.5.4 等值传递

​		**有一个非常大的 IN() 列表，而优化器发现存在 WHERE、ON 或者 USING 的字句，将这个列表的值和另一个表的某个列相关联。**

​		那么优化器会将 IN() 列表都复制应用到关联的各个表中。如果这个列表非常大，就会导致其他表的优化和执行都变慢。

### 6.5.5 并行执行

​		MySQL  无法利用多核特性来并行执行查询。

### 6.5.6 哈希关联

​		如果使用的不是 Memory 引擎，则可能无法使用哈希关联。

### 6.5.7 松散索引扫描

​		由于历史原因，MySQL 并不支持松散索引扫描，也就无法按照不连续的方式扫描一个索引。通常，MySQL 的索引扫描需要先定一个起点和终点。即使需要的数据只有这段索引中很少数的几个，MySQL 仍需要扫描这段索引中的每一个条目。图就不截了。

### 6.5.8 最大值和最小值优化

```sql
SELECT MIN(actor_id) FROM actor WHERE first_name = 'PENELOPE';
```

```SQL
SELECT actor_id FROM actor USE INDEX(PRIMARY) WHERE first_name = 'PENELOPE' LIMIT 1;
```

第一条查询语句会进行全表扫描，但其实找到的第一个 first_name = 'PENELOPE' 的记录，actor_id 就是最小的。所以可以改写成第二条查询语句。

### 6.5.9 在同一张表上查询和更新

MySQL 不允许对同一张表同时进行查询和更新。

```sql
-- 报错
UPDATE tb1 AS outer_tb1
	SET cnt = (
  	SELECT count(*)
    FROM tb1 AS inner_tb1
    WHERE inner_tb1.type = outer_tb1.type
  );
```

```sql
-- 子查询会在更新操作打开表之前就完成，下面的操作会正常执行
UPDATE tb1
	INNER JOIN(
  	SELECT type, count(*) AS cnt
    FROM tb1
    GROUP BY type
  ) AS der USING(type)
SET tb1.cnt = der.cnt;
```

## 6.6 查询优化器的提示(hint)

可以使用优化器提供的几个 hint 来控制最终的执行计划。这里就不举例了。

## 6.7 优化特定类型的查询

### 6.7.1 优化 count() 查询

##### count() 的作用

统计某个列值的数量(不包含 NULL)，如果在 COUNT() 的括号中指定了列或者列的表达式，则统计的就是这个表达式有值的结果数。如果使用的是 COUNT(*) 这种情况就是忽略所有的列直接统计所有的行数。还是有区别的。

##### count() 的优化

比如在 MyISAM 中，没有 WHERE 条件的 COUNT(*) 是非常快的，因为可以利用存储引擎的特性直接获取这个值。但是如果是统计某列值的数量，MyISAM 则没有任何优势。

```sql
SELECT COUNT(*) FROM city WHERE ID > 5;
```

```sql
SELECT (SELECT COUNT(*) FROM city) - count(*)
FROM city
WHERE ID <= 5;
```

以上就是一种简单的依靠 MyISAM 的特性进行优化的例子。

```sql
SELECT SUM(IF(color = 'blue', 1, 0)) AS blue, SUM(IF(color = 'red', 1, 0)) AS red
FROM items;
```

```sql
SELECT COUNT(color = 'blue' OR NULL) AS blue, COUNT(color = 'red' OR NULL) AS red
FROM items;
```

以上两种情况演示了 COUNT 的替代方法。

### 6.7.2 优化关联查询

+ **确保 ON 或者 USING 子句的列上有索引**。在创建索引的时候考虑关联顺序，当 表A 和 表B 用 列c 关联的时候，如果优化器的关联顺序是 B, A。则无须在 B 上加索引。一般来说，**只需要在关联顺序中的第二个表的相应列上创建索引。**
+ **确保 GROUP BY 和 ORDER BY 中的表达式只涉及到一个表中的列**，这样 MySQL 才有可能使用索引进行优化。

### 6.7.3 优化子查询

​		**尽可能使用关联查询代替。如果是 MySQL 5.6+ 可以忽略掉这条。**

### 6.7.4 优化 GROUP BY 和 DISTINCT

​		**它们都可以使用索引进行优化，** 但是当无法使用索引的时候，GROUP BY 使用两种策略来完成：1. 临时表 2. 文件排序 进行分组。如果需要对关联查询做分组, 并且是按照查找表中的某个列进行分组，那么通常查找表的标识列分组的效率会比其他列要高。

```sql
SELECT actor.first_name, actor.last_name, COUNT(*)
FROM film_actor
	INNER JOIN actor USING(actor_id)
GROUP BY actor.first_name, actor.last_name;
-- 与上一条分组语句来比，这条效率会更高
GROUP BY film_actor.actor_id;
```

​		如果没有通过 ORDER BY 字句显示地指定排序列，**当使用了 GROUP BY 的时候，结果集会自动按照分组的字段进行排序**。如果不需要的话可以使用 ORDER BY NULL。

### 6.7.5 优化 LIMIT 分页

​		尽可能多地使用索引覆盖扫面，而不是查询所有的列。再根据一次关联操作返回所需要的列。

```sql
SELECT film.film_id, film.description
FROM film
	INNER JOIN (
  	SELECT film_id
    FROM film
    ORDER BY title LIMIT 50, 5
  ) AS lim USING(film_id);
```

​		有时也可以将 LIMIT 转换为已知位置的查询，让 MySQL 通过范围扫描得到对应的结果。当然我感觉这个一般都用不到。

​		OFFSET 会导致 MySQL 扫描大量不需要的行然后抛弃掉，如果已知当前页数，再去只使用 LIMIT 的话，会快很多。

##### 另一种优化

​		**一个更好的设计是将具体的页换成 “下一页” 的按钮**，假设每页显示 20 条记录，那么在查询的时候，返回 21 条数据，假如第 21 条数据存在，则显示 “下一页”，否则不进行显示。

##### 使用缓存

​		先获取并缓存较多的数据，例如，缓存 1000 条，每次分页都从这个缓存中获取，这样做可以让应用程序根据结果集的大小采取不同的策略，如果结果集小于 1000， 就可以在页面上显示所有的分页链接。

### 6.7.7 优化 UNION 查询

​		很多优化策略在 UNION 查询中都无法很好使用。经常需要**手工地将 WHERE、LIMIT、ORDER BY 等子句 “下推” 到 UNION 的各个子查询中**，以便优化器可以充分利用这些条件进行优化。

​		**如无确实需要服务器消除重复的行，否则一定要用 UNION ALL。**使用 UNION 的话，MySQL 会给临时表加上 DISTINCT 选项。这样做代价极高。即使没有 ALL 关键字，也仍然会使用临时表进行存储结果。

### 6.7.8 静态查询分析

​		略

### 6.7.9 使用用户自定义变量

​		略

## 6.8 案例学习

### 6.8.1 使用 MySQL 构建一个对列表

+ 背景：

​		一个表包含多种类型的消费记录：未处理、已处理、正在处理，等。一个或多个消费线程在表中找到未处理的记录，生成正在处理，处理完成后再将记录更新为已处理状态。如：邮件发送、多命令处理、评论修改等。

+ 通常有两个原因使得大家认为这样的处理方式并不合适：

  + 随着对列表越来越大和索引深度的增加，找到未处理记录的速度会随之变慢。

    + 但是可以将队列表分为两部分来解决，将已处理和已归档的存放在历史表。这样就可以始终保证队列表很小。

  + 一般的处理过程是：先找到未处理记录然后加锁。加锁操作会让各个消费者进程增加竞争。

    + 一般尽量避免 SELECT FOR UPDATE。会导致大量事务阻塞并等待。

    

































