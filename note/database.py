"""
1. 磁盘IO与预读
    a. 磁盘读取分为寻道时间、旋转延迟、传输时间三个部分，这三个部分耗时相加就是一次磁盘IO的时间，大概9ms左右，这个成本是访问内存的十万倍左右
    b. 为了节省时间，采取了优化：预读；每一次IO,不仅仅把当前磁盘地址的数据加载到内存中，同时也把相邻数据也加载到内存缓冲区中
    c. 局部预读原理说明： 访问一个地址数据的时候，与其相邻的数据很快也会被访问到。 每次磁盘IO读取的数据我们成为一页， 一页的大小和操作系统有关系。4k or 8k

2. B-Tree(读作B树) 和 二叉查找树 不一样
    a. 二叉查找树的查询的时间复杂度O(logN),查找速度最快 和 比较次数最少。但是索引不用二叉查找树 而 使用B-Treede原因是因为磁盘IO的次数。
    b. 数据库索引是存储在磁盘上的，当表中数量比较大时，索引的大小也跟着增长，达到几个G甚至会更加多，当我们利用索引进行查询的时候，不可能把索引全部加载到内存中，
       只能逐一加载每个磁盘页，这里的磁盘页对应的就是索引树的节点。
    c. 最坏的情况下，根据二叉树的查找过程来看，树的高度和磁盘IO的次数是一样的，也就是说磁盘IO的次数由树的高度来决定
    d. 减少磁盘IO的次数就必须要压缩树的高度，就要让树又矮又胖
    
    def B-Tree
    1. 每个节点最多拥有m个子树
    2. 根节点至少有2个子树
    3. 分支节点至少拥有m/2子树（除了根结点和叶子节点）
    4. 所有叶子结点都应该在同一层，每个节点最多可以有m-1个key,并且以升序排列
    
    def B+Tree
    1. 一般数据库系统和文件系统中使用的B+Tree结构都在经典B+Tree的基础上进行了优化，增加了顺序访问指针
    2. 每个叶子节点增加一个指向相邻叶子节点的指针，就形成了带有顺序访问指针的B+Tree,做这个优化的目的就是为了提高区间访问的性能
    3. 红黑树等数据结构也可以用来实现索引，但是文件系统及数据库系统普遍采用B-/+Tree作为索引结构。
    
    索引本身很大，不可能全部都存储在内存中，因此索引往往以索引文件的形式存储在磁盘上，这样的话，索引查找过程中就要产生磁盘IO消耗上面。所以索引的结构组织要尽量减少查找过程中磁盘
    IO的存取次数。
    
    MyISAM 索引实现
    1. B+Tree作为索引结构，叶节点的data域存放的是数据记录的地址
"""