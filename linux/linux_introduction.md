# 章一：Linux 内核简介

### 1.1 Unix 的历史

```markdown
Unix 特点：
1. 简洁：仅提供几百个系统调用
2. 所有的东西被当成文件对待：这种抽象使得对数据和对设备的操作都可以通过一套相同的系统调用接口来完成[open()、read()、write()、lseek()]。
3. Unix 内核和相关的系统工具软件是用 C 编写而成的，因此 Unix 在各种硬件体系架构面前都具备惊人的移植能力。
4. Unix 的进程创建非常迅速，且有一个独特的 fork() 系统调用。
5. Unix 提供了一套非常简单但却很稳定的进程间通信元语。
```

### 1.2 Linux 简介

```markdown
Linux 是类 Unix 系统。Linux 系统的基础是 内核、C库、工具集、系统的基本工具（登录程序 和 shell）本书之后提到的 Linux 均指 Linux 内核部分。
```

### 1.3 操作系统和内核简介

```markdown
操作系统：
指整个系统中负责完成最基本功能和系统管理的那些部分。这部分包括了 内核、设备驱动程序、启动引导程序、命令行 shell、用户界面、基本的文件管理工具、系统工具。

内核：
系统的其它部分必须依靠内核这部分软件提供的服务，像管理硬件设备、分配系统资源等。组成：
a. 负责响应中断的中断服务程序。
b. 负责管理多个进程从而分享处理器时间的调度程序。
c. 负责管理进程地址空间的内存管理程序。
d. 网络。
e. 进程间通信等系统服务程序。
```

#### 1.3.1 应用程序和内核的通信过程简介

```markdown
内核空间：
内核独立于普通应用程序，一般处于系统态，拥有受保护的内存空间和访问硬件设备的所有权限。这种系统态和被保护起来的内存空间，就是内核空间。

用户空间：
应用程序在用户空间执行，它们只能看到允许它们使用的部分系统资源，并且只使用某些特定的系统功能，不能直接访问硬件，也不能访问内核划分给别人的内存范围，还有一些其他的使用限制。

过程：
当内核运行的时候，系统以内核态进入内核空间执行。执行一个普通用户程序时，系统将以用户态进入用户空间执行。应用程序要通过系统调用来与内核进行通信 或 使用一些库函数，库函数再调用系统调用。
```

#### 1.3.2 中断机制

```markdown
当硬件设备想和系统通信时，它先发出一个异步的中断信号去打断处理器的执行，继而打断内核的执行。中断通常对应一个中断号，内核通过这个中断号查找响应的中断服务程序，然后调用这个程序来处理中断。

Linux 的中断服务程序不在进程上下文中执行，它们在一个与所有进程都无关的、专门的中断上下文中运行。这样的环境就是为保证中断服务程序能在第一时间响应和处理中断请求，然后快速退出。
```

#### 1.3.3 总结

```markdown
处理器运行于用户空间，执行用户进程。
处理器运行于内核空间，处于进程上下文，代表某个特定的进程执行。
处理器运行于内核空间，处于中断上下文，与任何进程无关，处理某个特定的中断。

以上所列几乎包括所有情况，有一些例外：当 CPU 空闲时，内核就运行一个空进程，处于进程上下文，但是运行于内核空间。
```

### 1.4.1 Linux 内核和 Unix 内核的比较

```markdown
单内核：
指从整体上作为一个单独的大过程来实现，同时也运行在一个单独的地址空间上。这样的内核通常以单个静态二进制文件的形式存放于磁盘中。所有的内核服务都在大的内核地址空间运行，内核之间的通信就是微不足道的，因为大家都运行在内核态，并身处于同一地址空间(内核直接调用函数即可)。因此单内核的优点：1.简单;2.性能高。

微内核：
微内核的功能被划分为多个独立的过程，每个过程为一个服务器。所有的服务器都保持独立并运行在各自的地址空间上。因此要通过消息传递来处理微内核通信：系统采用了进程间通信(IPC)机制。优点：服务其各自独立避免一个服务器失效会祸及另一个。缺点：IPC机制开销大于函数调用，涉及用户空间、内核空间的上下文切换，消息传递需要一定的周期。

Linux 和 Unix 都是单内核，但是 Linux 吸收了微内核涉及中的模块化设计、抢占式内核、支持内核线程、动态装载内核模块的能力。并且规避了微内核的设计缺陷，让所有的事情都运行在内核态，直接调用函数，无需消息传递。
```

### 1.5 Linux 内核版本

```markdown
Linux 内核版本主要分为 稳定版 和 开发版本。

Linux 的内核命名机制：
使用 "." 分隔的数字来代表不同的内核版本。第一个数字是主版本号，第二个数字是从版本号，第三个数字是修订版本号，第四个可选的数字为稳定版本号(stable version)。如果从版本号(第二个数字)是偶数，就是稳定版本。如果是奇数，就是开发版本。
```




























































