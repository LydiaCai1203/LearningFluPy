## 第 11 章：定时器 和 时间管理

```markdown
内核中有大量的函数都是基于时间驱动的。有些函数是周期执行的，比如 屏幕刷新。另外一些函数则需要推后执行，比如：要推后执行的磁盘 I/O 操作等。这些情况需要内核提供时间，此外，内核还必须管理系统的运行时间以及当前日期和时间。

注意这里 相对时间 和 绝对时间 的概念。周期性产生的事件都是由系统定时器驱动的。系统定时器是一种可编程的硬件芯片，它能以固定频率产生中断。该中断就是所谓的定时器中断。它所对应的中断处理程序负责: 1.更新系统时间。2.执行需要周期性运行的任务。

除此之外还有一个动态定时器，一种用于推迟执行程序的工具。内核可以动态创建或撤销动态定时器。
```

### 11.1 内核中时间的概念

```markdown
内核必须在硬件的帮助下才能计算和管理时间。系统定时器就是一个用以计算流逝的时间的硬件。系统定时器会以某种频率自行触发(也被称为击中时钟中断)。该频率可以通过编程预定，称作 节拍率(tick rate)。当时钟中断发生时，内核就通过一种特殊的中断处理程序对其进行处理。

预编的节拍率对内核是可知的，内核知道连续两次时钟中断的间隔时间，这个间隔时间被成为 节拍(tick), 它等于 节拍率分之一(1/tick_rate) 秒。内核就是靠这种已知的时钟中断间隔来计算墙上时间和系统运行时间的。另外内核也为用户空间提供了一组系统调用来获取实际日期和时间。这样用户程序也可以知道流逝的时间了。
```

```markdown
利用时钟中断周期执行的工作有：
1. 更新系统运行时间。
2. 更新实际时间。
3. 检查当前进程是否用尽了自己的时间片，如果用尽就重新进行调度。
4. 运行超时的动态定时器。
5. 更新资源消耗和处理器时间的统计值。

这其中某些工作，是每次时钟中断发生都需要执行的。也有一些只需要每 n 次时钟中断才运行一次。
```

### 11.2 节拍率：HZ

```markdown
节拍率 是通过静态预处理定义的，也就是 HZ。系统启动时按照 HZ 对硬件进行设置。不同的体系结构，有不同的节拍率。在 x86 体系结构中，系统定时器频率默认值为 100。也就是说，每秒钟会发生 100 次的时钟中断，每 10ms 产生一次。在其它的体系结构中节拍率则为 250 和 1000, 分别对应的是 4ms 和 1ms。

节拍率是可调的，不是一成不变的。内核中的全部时间概念都来源于周期运行的系统时钟。因此要选择一个合适的频率。
```

### 11.2.1 理想的 HZ 值

```markdown
Linux 问世以来，i386 体系中的 tick rate 是 100HZ，但是在 2.5 开发版内核中，被提高到了 1000HZ。时钟中断产生的更加频繁，也就意味着中断处理程序会更频繁地执行。

优点：
1. 更高的时钟中断解析度，可提高时间驱动事件的解析度。
2. 提高了时间驱动事件的准确度。
3. 以来定时值执行的系统调用，如 poll() 和 select()，能够以更高的精度运行。
4. 对诸如资源消耗和系统运行时间等的测量会有更精细的解析度。
5. 提高进程抢占的准确度。

缺点：
1. 处理器必须花时间来执行时钟中断处理程序，中断处理程序占用处理器的时间越多，处理器在其它工作上的时间就越少。
2. 会频繁打乱处理器高速缓存并且增加耗电。
```

**无节拍的 OS**

```markdown
Linux 提供 "无节拍操作" 选项，当编译内核时设置了 CONFIG_HZ 这样的选项，系统就会根据这个选项动态地调度时钟中断。并不是每隔固定的时间间隔触发中断，而是按需动态调度和重新设置。如果下一个时钟频率设置为 3ms，就每 3ms 触发一次时钟中断。之后，如果 50ms 内都无事可做，内核就以 50ms 重新调度时钟中断。

这样做不仅可以减少开销，还可以省电。特别在系统空闲时，对于无节拍的系统，空闲档期不会被不必要的时钟中断所打断。减少了系统的能耗。
```

### 11.3 jiffies

```markdown
全局变量 jiffies 用来记录自系统启动以来产生的节拍的总数。启动时，内核将该变量初始化为 0，此后，每次时钟中断，中断处理程序就会增加该值。由于 1s 内时钟中断的次数等于 tick rate, 因此 jiffies 1s 内增加的值也等于 tick rate。

系统运行的时间(s) = jiffies / tick rate
```

#### 11.3.3 用户空间 和 HZ

```markdown
在 2.6 版以前的内核中，如果改变内核中 HZ 的值，会被用户空间中某些程序造成异常的结果。内核定义了 USER_HZ 来代表用户空间看到的 HZ 值。具体的算法不介绍了，这一节我都没看懂。
```

### 11.4 硬时钟 和 定时器

#### 11.4.1 实时时钟

```markdown
实时时钟（RTC）是用来持久存放系统时间的设备，即使系统关闭后，它也可以靠主板上的微型电池提供的店里保持系统的计时。当系统启动时，内核通过读取 RTC 来初始墙上的时间，该时间存放在 xtime 变量中。实时时钟最主要的作用仍然是启动的时候初始化 xtime 变量。
```

#### 11.4.2 系统定时器

```markdown
系统定时器是内核定时机制中最为重要的角色。系统定时器的基本思想：提供一种周期性触发中断机制。有通过对电子晶振进行分频来实现系统定时器的。有提供一个衰减测量器，该测量器会设置一个初始值，该值以固定频率递减，当减到 0 的时候，触发中断。

在 x86 体系结构中，主要采用可编程中断时钟(PIT)。从 DOS 时代开始，就开始以它作为时钟中断源。内核在启动时对 PIT 进行编程初始化，使其能够以 HZ/s 的频率产生时钟中断。
```

### 11.5 时钟中断处理程序

```markdown
时钟中断处理程序分为：1. 体系结构相关的部分。2. 体系结构无关的部分。

与体系结构相关的例程作为 系统定时器的中断处理程序 注册到内核中，以便产生时钟中断时，它能够相应地运行。虽然处理程序的具体工作依赖于体系结构，但最低限度也要完成如下工作：略。

具体的 节拍计算方式，没看懂，暂时先不记录了。
```

### 11.6 实际时间

```markdown
当前实际时间(墙上时间) 定义在文件 `kernel/time/timekeeping.c` 的 `xtime` 变量中，`xtime.tv_sec`以秒为单位，存放着自 1970年1月1日(UTC) 以来经过的时间。1970年1月1日 被称为纪元，多数 Unix 系统的墙上时间都是基于该 纪元 而言的。`xtime.v_nsec` 记录自上一秒开始经过的 ns 数。
```

```markdown
读取 `xtime` 的时候需要获取 seqlock, 读取时间的函数不断循环，直到读者确认读取数据时没有写操作介入。如果发现循环期间有时钟中断处理程序更新 `xtime`，就会继续循环等待。
```

### 11.7 定时器

```markdown
定时器(动态定时器/内核定时器)，是管理内核流逝时间的基础。之前提到的下半部机制，就是为了将工作放到以后去执行。我们需要一种工具，能够使工作在指定时间点上执行，内核定时器正是解决这个问题的理想工具。

定时器的使用很简单，只需要执行一些初始化工作，设置一个超时时间，指定超时发生后执行的函数，再激活定时器就可以了。而指定的函数，将在定时器到期时自动执行。定时器在超时以后就会自行撤销，但是可以不断被创建，运行次数不受限制，这也是它被称为 动态定时器 的原因。
```
