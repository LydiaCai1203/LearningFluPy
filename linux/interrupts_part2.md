## 第八章：下半部和推后执行的工作

### 8.1 为什么要使用下半部

1. **中断处理程序（上半部）的局限性**

```markdown
1. 中断处理程序以异步方式执行，有可能会打断其它重要代码(甚至是其它的中断处理程序)。因此，为了避免被打断的代码停止时间过长，中断处理程序应该执行地越快越好。

2. 假设当前有一个中断处理程序正在执行，如果 `IRQF_DISABLED` 没有被设置，则与该中断同级的其它中断会被屏蔽。如果 `IRQF_DISABLED` 有被设置，当前处理器上其它所有中断都会被屏蔽。因为禁止中断后硬件与操作系统无法通信。

3. 由于中断处理程序往往需要对硬件进行操作，所以它们通常有很高的时限要求。

4. 中断处理程序不在进程上下文中运行，所以它们不能阻塞，这也限制了中断处理程序可以做的事情。

正因为上半部有许多的局限性，我们需要中断处理程序尽快完成，因此需要将一些工作放到后面去做。让它们在系统不太繁忙并且中断恢复后执行就可以。通常下半部在中断处理程序一返回就会马上执行，且下半部在运行的时候，允许响应所有的中断。
```

2. **下半部、软中断、tasklet、任务队列**

```markdown
下半部：指代中断处理流程中推后执行的那一部分。

目前有三种机制可以用来实现将工作推后执行：软中断、tasklet、工作队列。其中 tasklet 通过软中断实现。

- 任务队列（已剔除）：
内核定义一组队列，每个队列包含一组等待调用的函数。根据其所处队列的位置，这些函数会在某个时刻执行。启动程序可以把它们的下半部注册到合适的队列上去。

- 软中断：
软中断是一组静态定义的下半部接口，有 32 个，可以在所有的处理器上同时执行，即使两个类型相同也可以。

- tasklet
基于软中断实现的，两个不同类型的 tasklet 可以在不同的处理器上同时执行，但类型相同的 tasklet 不可以同时执行。
```

3. **内核定时器**

```markdown
内核定时器也是一种可以将工作推后执行的机制。内核定时器把操作推迟到某个确定的时间段之后执行。
```

### 8.2 软中断

1. **软中断处理程序**

```markdown
软中断是在编译期间静态分配的。软中断在 Linux 中是一个结构体 `softirq_action`，结构体内有一个指针数组，每个被注册的软中断都占据该数组的一项，因此最多可能有 32 个软中断。

软中断处理程序的函数签名：`void softirq_handler(struct softirq_action *)`。其中 `softirq` 指向哪个软中断函数，就会调用该软中断函数。
```

2. **执行软中断**

```markdown
一个注册的软中断必须在被标记后才会执行，这叫做 触发软中断。通常，中断处理程序会在返回前标记它的软中断，使其在稍后被执行。

待处理的软中断在下列地方会被检查和执行：
1. 从一个硬件中断代码处返回时。
2. 在 ksoftirqd 内核线程中。
3. 在那些显式检查和执行待处理的软中断的代码中，如网络子系统中。
```

### 8.3 tasklet

```markdown
通常应该选择 tasklet 而非软中断。软中断只在那些执行频率很高和连续性要求很高的情况下才需要。tasklet 有更广泛的用途。tasklet 是在两种软中断类型的基础上实现的，也就是说 tasklet 是软中断的一种特殊用法：延迟情况下的串行执行。
```

### 8.4 工作队列

```markdown
软中断同样执行于中断上下文，是不可以阻塞和睡眠的，而 tasklet 使用软中断实现，当然也是一样。因此，工作队列应运而生。由工作线程去执行工作队列中的工作，Linux 中默认的工作线程为 events。工作队列允许重新调度甚至是睡眠。
```

### 8.5 下半部机制的选择

```markdown
软中断：
允许两个甚至更多的软中断处理程序并行执行，因此软中断处理函数必须提供一些确保共享数据安全的步骤。因此对时间和执行频率有很高的要求的应用来说，软中断是一个不错的选择。性能当然是最高的。

tasklet:
接口简单，且由于其串行化的特地，会使得开发起来也比较简单。驱动程序的开发者应当尽可能使用 tasklet 而不是软中断。

工作队列：
如果需要把任务推后到进程上下文中完成，只能选择工作队列。工作队列造成的开销最大，因为牵扯到内核线程甚至是上下文切换。如果每秒钟可能有几千次中断，采用另外两种机制可能会更合适。
```

### 8.6 在下半部之间加锁

```markdown
在使用下半部机制时，即使是在一个单处理器的系统上，避免共享数据被同时访问也是重要的。一个下半部实际可能在任何时候被执行。使用 tasklet 的好处在于，它自己会负责执行的序列化保障，因为两个相同类型的 tasklet 不允许同时执行，即使在不同的处理器上。

如果进程上下文和一个下半部共享数据，在访问这些数据之前，你需要禁止下半部的处理并得到锁的使用权。如果中断上下文和一个下半部共享数据，在访问这些数据之前，你需要禁止中断并得到锁的使用。
```




























































