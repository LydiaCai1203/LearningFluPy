## 第十章：内核同步方法

Linux 内核提供了一组完备的同步方法，使得内核开发者们能编写出高效而又自由竞争的代码。

### 10.1 原子操作

```markdown
原子操作是一组不能被分割的指令。它防止了竞争的发生保证了操作结果总是一致的。内核提供了两组原子操作接口：1. 针对整数进行操作。2. 针对单独的位进行操作。
```

### 10.2 自旋锁 (spin lock)

```markdown
自旋锁最多只能被一个可执行线程持有，如果一个执行线程试图获得一个被已经持有的自旋锁，该线程会一直进行忙循环、旋转、等待锁重新可用。同一个锁可以用在多个位置。缺点就是特别浪费处理器时间，因此自旋锁不应该被长时间持有。

当然还可以让线程睡眠，直到锁重新可用时再唤醒它，这也可以解决锁争用的问题。这样虽然处理器不必循环等待，但会涉及两次上下文切换，且上下文切换会涉及到更多的代码。因此，持有自旋锁的时间最好小于完成两次上下文切换的耗时。
```

```markdown
自旋锁往往通过汇编实现，且在同一时刻至多被一个执行线程持有。这就为多处理器机器提供了防止并发访问所需要的保护机制。在单处理器机器上，编译的时候是不会加入自旋锁的。它仅仅被当作一个设置内核抢占机制是否被启用的开关，如果禁止内核抢占，那么在编译时自旋锁会被完全剔除内核。

自旋锁可以用在中断处理程序中，但是一定要记得获取锁之前，先禁止本地中断。否则中断处理程序会先打断正持有锁的内核代码，然后自旋获取锁。但是此时内核代码被打断了也不可能释放锁。因此就会出现双重请求死锁。
```

### 10.3 读-写 自旋锁

```markdown
Linux 内核提供了专门的 读-写 自旋锁，这种自旋锁分为 读、写 两种不同的场景。一个或者多个读任务可以并发地持有 读者锁；相反，用于写的锁最多只能被一个写任务锁持有，而且此时不能有并发的读操作。有时也把 读锁 叫做 共享锁。把 写锁 叫做 排他锁。

这种 读写锁 也会引发死锁，加入有读者正在进行操作，此时包含写操作的中断发生了。由于读锁还未被释放，写锁会发生自旋。但是读操作被打断，只能在中断返回后才可以继续。此时死锁就发生了。因此如果没有明确的读写划分，使用一般的 自旋锁 就可以了。
```

### 10.4 信号量

```markdown
当加锁时间不长，且不希望代码睡眠时，使用自旋锁是最佳选择。反之，则可以使用信号量。

Linux 中的信号量是一种睡眠锁，如果有一个任务试图获得一个不可用的信号量时，信号量会将其推进一个等待队列，然后让其睡眠。这时处理器能重获自由，从而去执行其他代码。当持有的信号量可用时，处于等待队列中的那个任务将被唤醒，并获得该信号量。

信号量相比自旋锁，有更好的处理器利用率，但是却有更大的上下文切换的开销。事实上在中断上下文中也无法调度信号量。
```

#### 10.4.1 计数信号量 和 二值信号量

```markdown
信号量可以同时允许任意数量的锁持有者，而自旋锁在一个时刻最多只允许一个任务持有。信号量同时允许的持有者数量可以在声明信号量时就指定。这个值：使用者数量。

二值信号量：
使用者数量为 1。它只能被 1个/ 0个 任务所持有。被成为 互斥信号量。

计数信号量：
使用者数量为 大于1 的整数。它允许一个时刻至多有 count 个锁持有者。这种信号量用来对特定的代码加以限制，内核中使用它的机会不多。

信号量竟然是 Dijkstra 提出的... 厉害。
```

**原子操作 P() 和 V()**

```markdown
P 和 V 来自荷兰语 Proberen 和 Vershogen。P 有探查的意思，V 有增加操作的意思。后来的系统把这两种操作分别叫做 down() 和 up()。down() 就是通过对信号量计数 减1 来获得一个信号量，如果结果 大于等于0，就获得信号量，任务就可以进入临界区。up() 的操作就是用来释放信号量的，如果在信号量上的等待队列不为空，那么处于队列中等待的任务在被唤醒的同时会获得该信号量。
```

### 10.5 读-写 信号量

```markdown
所有 读-写 信号量都是互斥信号量。它们的引用计数都是 1。虽然它们只对写者互斥，不对读者。只要没有写者，并发持有读锁的读者数量不限。但是只有唯一的写者(在没有读者时)可以获得写锁。所有 读-写 锁的睡眠都不会被信号打断。

读-写 信号量 相比 读-写 自旋锁 多了一种特有的操作：downgrade_write()。这个函数可以动态地将获取的写锁转换为读锁。除非代码中的读写操作可以明白无误地分开来，否则最好不要使用它。
```

### 10.6 互斥体

```markdown
信号量用途通用，没有多少使用限制，这使得信号量适合用于那些较复杂的、未明情况下的互斥访问，比如内核与用户空间复杂的交互行为。但是简单的锁定使用信号量并不方便，因此 Linux 引入了 互斥体（mutex）。这里指的是任何可以睡眠的强制互斥锁。

互斥体（mutex）行为和使用计数为 1 的信号量类似，操作接口更简单，实现更高效，而且使用限制更强。它的特点是：
1. 任何时刻只有一个任务可以持有 mutex, 它的计数永远是 1。
2. 给 mutex 上锁者必须负责给其解锁。因此不适合内核同用户空间复杂的同步场景了。
3. 递归地上锁和解锁是不被允许的。
4. 当持有一个 mutex 时，进程不可以退出。
5. mutex 不能在中断或者下半部中使用。
```

#### 10.6.1 信号量 和 互斥体

```markdown
互斥体 和 信号量 很相似，除非 mutex 的某个约束妨碍你使用了，否则相比信号量要优先使用 mutex。
```

#### 10.6.2 自旋锁 和 互斥体

```markdown
1. 低开销加锁、短期锁定、中断上下文中加锁：优先使用 自旋锁。
2. 长期加锁、持有锁者需要睡眠：优先使用互斥体。
```

### 10.7 完成变量

```markdown
如果在内核中一个任务需要发出信号通知另一个任务发生了某个特定事件，利用 完成变量(completion variable) 是使两个任务得以同步的简单方法。如果一个任务要执行一些工作时，另一个任务就会在完成变量上等待。当这个任务完成工作后，会使用完成变量去唤醒在等待的任务。

完成变量 仅仅提供了代替 信号量 的一个简单的解决方法。例如：当子进程执行或者退出时，`vfork()` 使用完成变量来唤醒父进程。
```

### 10.8 BLK：大内核锁

```markdown
BLK 是一个全局自旋锁，使用它主要是为了方便实现从 Linux 最初的 SMP 过渡到细粒度加锁机制。其它特性再去看书把，这里不记录了。
```

### 10.9 顺序锁（seq 锁）

```markdown
在 Linux 2.6 版本才引入的一种新型锁。用于读写共享数据。实现这种锁主要依靠一个序列计数器。当有疑义的数据被写入时，会得到一个锁，并且序列值会增加。在读取数据之前和之后，序列号都会被读取。如果读取前后两次获取的序列号值都相同，说明在读操作进行的过程中没有被写操作打断过。

序列锁允许读写并发，但是依旧是不允许多个写者并发的。另外写者获取写锁的时候，会对计数器加1，释放写锁的时候会减1。因此如果读到的序列值是偶数，也可以认为没有写操作发生。
```

```markdown
挂起的写者会不断地使得读操作循环，直到不再有任何写者持有锁为止。综上所述，序列锁的适用场景为：
1. 你的数据存在很多读者, 且写者很少。
2. 虽然写者很少，但是你希望写优先于读，不允许读者让写者饥饿。
3. 你的数据很简单，简单结构。
```

```markdown
Linux 中有一个序列锁叫 `jiffies`, 该变量存储了 Linux 机器启动到当前的时间。使用一个 64bit 的变量。没看懂，后面再看。
```

### 10.10 禁止抢占

```markdown
为了避免抢占，内核抢占代码使用自旋锁来作为非抢占区域的标记。如果一个自旋锁被持有，内核便不能进行抢占。这种简单的变化使得内核也是 抢占安全的。

某些情况下，即使用不到自旋锁，也是希望避免抢占的。比如某个数据，foo 正在访问处理。此时来了个 foolish 抢占了，也要访问这个数据。这样即使是单处理器，也要避免抢占的。这时可以用 `preempt_disable()` 禁止内核抢占。
```

### 10.11 顺序和屏障

```markdown
略，这个看完 11 章再回头总结。
```




























