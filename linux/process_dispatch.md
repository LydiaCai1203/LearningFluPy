## 第四章：进程调度

```markdown
进程调度程序：
确保进程能有效工作的一个内核子系统。调度程序负责决定哪个进程投入运行，何时运行以及运行多长时间。进程调度程序可看作是在可运行态进程之间分配有限的处理器时间资源的内核子系统。
```

### 4.1 多任务

```markdown
多任务操作系统：
就是能并发地交互执行多个进程的操作系统。无论是单处理器还是多处理器上，多任务操作系统都能使多个进程位于阻塞或睡眠的状态。即进程即使位于内存，但并不处于可运行的状态，相反这些进程利用内核阻塞自己，直到某一事件(键盘输入、网络数据)发生。
```

**非抢占式多任务(cooperative multitasking)**

```markdown
概念：
除非进程自己主动停止运行，否则它会一直运行。进程主动挂起自己的操作称为让步(yielding)。理想情况下，进程通常做出让步，以便让每个可运行进程享有足够的处理器时间。

缺点：
一个决不做出让步的悬挂进程能使进程崩溃。且进程独占处理器的时间可能超出用户预料。

例子：
MacOS 9 && Windows 3.1 及其前身
```

**抢占式多任务(preemptive multitasking)**

```markdown
概念：
由调度程序来决定什么时候停止一个进程的运行，以便其它进程能够得到执行机会。这个强制的挂起动作就叫做抢占(preemptive multitasking)。进程在被抢占之前能够运行的时间是预先设置好的，即进程的时间片(timeslice)。时间片就是分配给每个可运行进程的处理器时间段。

优点：
能使进程调度程序从系统全局的角度做出调度决定，避免个别系统独占系统资源。

当今众多操作系统：
对程序运行采用了动态时间片计算的方式，且引入了可配置的计算策略。

Linux:
并未采用时间片来达到公平的调度。
```

### 4.2 Linux 的进程调度

```markdown
Linux 2.5 系列内核中，采用了一种叫做 O(1) 调度程序的新调度程序。主要改变有：静态时间片算法、针对每一处理器的运行队列。O(1) 调度器在数以十计的多处理器环境的环境下尚能表现出近乎完美的性能和可扩展性，但是在有很多交互程序要运行的桌面系统上则表现不佳。

Linux 2.6 开始，为了提高对交互程序的调度性能引入了新的进程调度算法。最为著名的是：反转楼梯最后期限调度算法。该算法吸取了队列理论，将公平调度的概念引入了 Linux 调度程序，在 Linux 2.6.23 中替代了 O(1) 调度算法，被称为 "完全公平调度算法(CFS)"。
```

### 4.3 策略

```markdown
概念：
策略决定调度程序在何时让什么进程运行。策略还要负责优化使用处理器时间，是非常重要的一环。
```

#### 4.3.1 I/O 消耗型和处理器消耗型的进程

```markdown
I/O 消耗型：
指进程的大部分时间都用来提交 I/O 请求或是等待 I/O 请求。这样的进程经常处于可运行状态，通常都是运行短短的一会儿，因为它在等待更多的 I/O 请求时最后总会阻塞(键盘输入、网络I/O)。多数用户图形界面程序都属于 I/O 密集型，因为它们会在多数时间里都等待来自鼠标或是键盘的用户交互操作。

处理器消耗型：
指进程把时间大多用在执行代码上，除非被抢占，否则一直不停地运行，因为它们没有太多 I/O 需求。从系统响应速度考虑，调度器不应该经常让它们运行。对于这类处理器消耗型的进程(数学计算程序、死循环)，调度策略往往是尽量降低它们的调度频率，延长其运行时间。

调度策略：
在 进程响应迅速 和 最大系统利用率(高吞吐量) 中寻找平衡点。Unix 系统的调度程序更倾向于 I/O 消耗型程序，提供更好的程序响应速度。Linux 为保证 交互式应用 和 桌面系统 的性能，缩短响应时间，也倾向于 I/O 消耗型程序。但是也并未忽略处理器消耗型的进程。
```

#### 4.3.2 进程优先级

```markdown
概念：
基于优先级的调度，根据 进程的价值 和其 对处理器时间的需求 来对进程分级的想法。
优先级高的进程先运行，低的后运行，相同优先级的进程按照轮转方式进行调度，并未被 Linux 完全采用。调度程序总是选择时间片未用尽且优先级最高的进程运行。用户和系统都可以通过设置进程的优先级来影响系统的调度。

两种不同的优先级范围：
1. nice 值, [-20, 19]，默认值为 0。越大的 nice 值意味着越低的优先级，越小的 nice 值意味拥有更多的处理器时间。可以通过 `ps -el` 查看，其中 `NL` 一列即 nice 值。
2. 实时优先级, [0, 99], 越高的实时优先级数值意味着进程的优先级越高。任何实时进程的优先级都高于普通的进程。大部分现代的 Unix 都提供类似的机制。`ps -eo state,uid,pid,rtprio` 查看进程列表，如果 `rtprio` 实时优先级列下显示的是 `-` 则说明不是实时优先级。
```

#### 4.3.3 时间片

```markdown
概念：
表明进程在被抢占前所能持续运行的时间。调度策略必须规定一个默认的时间片，时间片太长会导致交互响应表现欠佳，太短会明显增大进程切换带来的处理器耗时。其中 I/O 消耗型不需要长的时间片，处理器消耗型的进程则希望越长越好，其中一个原因是：可以让它们的高速缓存命中率更高。

Linux 的实现：
并未直接分配时间片到进程，而是将处理器的 使用比 划分给了进程。进程所能获得的处理器时间其实和系统负载密切相关。这个比例进一步会收到进程 nice 值的影响。

Linux 系统是抢占式的，当一个进程进入可运行状态，它就被准许投入运行。其它多数 OS 中，是否要将一个进程立刻投入运行(抢占当前进程)，完全由进程优先级和是否有时间片决定的。

在 Linux 中使用的 CFS 调度器，其抢占时机取决于新的可运行程序消耗了多少处理器使用比。如果消耗的使用比比当前进程小，新进程立刻投入运行，抢占当前进程。否则推迟运行。
```

#### 4.3.4 调度策略的活动

```markdown
背景：
文字编辑程序(I/O 消耗型) 和 视频编码程序(处理器消耗型)。注意 文字编辑程序 需要更快的响应。因此我们是希望当文字编辑程序在需要处理器时，总能抢占视频编码程序。

Linux:
分配一个给定的处理器使用比。比如，文字编辑程序 和 视频编码程序 拥有同样的 nice 值，处理器的使用比都是 50%，当 文字编辑程序 被唤醒时，CFS 会发现 文字编辑程序 运行的时间要更短，秉承绝对公平的原则，因此会立刻让其抢占 视频编码程序。
```

### 4.4 Linux 调度算法

#### 4.4.1 调度器类

```markdown
Linux 调度器是以模块方式提供的，这样允许不同类型的进程可以有针对性地选择调度算法。这种模块化结构被成为调度器类(scheduler classes)，允许多种不同的可动态添加的调度算法并存。每个调度器都有一个优先级，按照优先级顺序遍历调度类，拥有一个可执行进程的最高优先级的调度器类胜出，去选择下面要执行的那个程序。

CSF，完全公平调度，针对普通进程的调度类。
```

#### 4.4.2 Unix 系统中的进程调度

[看书没看懂](https://zhuanlan.zhihu.com/p/53084328)

```markdown
在 Unix 系统中，优先级以 nice 值形式输出给用户空间。传统 Unix 进程调度中存在的问题：

1. nice 越大，时间片越小，切换会越频繁。时间片小只是代表需要处理器时间短，不等同于需要频繁切换，如 CPU 消耗型任务。
2. nice 和 时间片大小 并不是线性关系，nice 值减少 1，减少多少时间片的长度要依据 nice 值的大小决定。
3. 时间片必须是定时器节拍器的整数倍，时间片长度会受到节拍器的影响。
4. 为了优化交互任务而故意提高优先级，即使交互任务的时间片已经用尽。这样会损害系统中其它进程的利益。

造成这些问题的实质原因：
分配绝对的时间片引发的固定的切换频率，给公平性造成了很大变数，CFS 采用的方法是对时间片分配方式进行根本性的重新设计，完全摒弃时间片，分配给进程一个处理器使用比重。
```

#### 4.4.3 完全公平调度(CFS)

```markdown
每个进程运行无限小的时间片不高效：
1. 调度时进程抢占上下文切换有消耗。
2. 影响缓存的效率。

CFS：
1. 允许每个进程运行一段时间、循环轮转、选择运行最少的进程作为下一个运行进程。
2. CFS 在所有可运行进程总数基础上计算出一个进程应该运行多久，而非依赖 nice 计算时间片。
3. nice 在 CFS 中被作为进程获得的处理器运行比的权重。每个进程都按其权重在全部可运行进程中所占比例的 "时间片" 来运行。
```

**目标延迟**

```markdown
为了计算准确的时间片，CFS 为完美多任务中的无限小调度周期的近似值设立了一个小目标，这个目标称为 "目标延迟"，越小的调度周期带来越好的交互性，同时更接近完美的多任务。但是也必须承受更高的切换代价和更差的系统总吞吐能力。假如 目标延迟 为 20ms, 假如有 4个任务，每个只能运行 5ms, 假如有 20个任务，每个只能运行 1ms。
```

**最小粒度**

```markdown
当可运行任务数量趋于无限，它们各自获得的处理器使用比和时间片都将趋于 0。这样无疑会造成不可接受的切换消耗。最小粒度就是每个进程获得的时间片底线，默认值为 1ms。
```

**例子**

```markdown
一个进程 nice(0), 另一个进程 nice(5)，nice(5) 的处理器权重是 nice(0) 的 1/3。如果我们的目标延迟是 20ms, 则 nice(5) 会获得 15ms 的时间，nice(0) 会获得 5ms 的时间。绝对的 nice 值不再影响调度决策，只有相对值才会影响处理器时间的分配比例。
```

**总结**

```markdown
CFS 称为公平调度器是因为它确保给每个进程公平的处理器使用比。
```

### 4.5 Linux 调度的实现

#### 4.5.1 时间记账

```markdown
所有的调度器都要对进程运行时间记账。多数 Unix 系统，分配一个时间片给每一个进程，当每次系统时钟节拍发生时，时间片都会被减少一个节拍周期。当一个进程的时间片被减少到 0 时，会被另一个尚未到 0 的时间片可运行进程抢占。
```

**调度器实体结构**

```python
CFS 不再有时间片的概念，但是必须维护每个进程运行的时间记账，因为它需要确保每个进程只在公平分配给它的处理器时间内运行。CFS 使用调度器实体结构为 `sched_entity`, 调度器实体结构作为一个名为 `se` 的成员变量，位于 `struct task_struct` 内。
```

**虚拟实时**

```markdown
`vruntime` 存放进程的虚拟运行时间，CFS 使用它来记录一个程序到底运行了多长时间以及它还应该再运行多久，单位是 `ns`。
```

#### 4.5.2 进程选择

```markdown
要知道，若存在一个完美的多任务处理器，所有可运行进程的 `vruntime` 将一致。因此 CFS 的规则是：当 CFS 需要选择下一个运行进程时，它会挑一个具有最小的 `vruntime` 进程。这就是 CFS 调度算法的核心。

CFS 使用红黑树组织可运行进程队列，并利用其找到最小 `vruntime` 值的进程。在 Linux 中，红黑树(rbtree) 是一个自平衡二叉搜索树。

查：
rbtree 存储了系统中所有的可运行进程，节点的键值就是可运行进程的 `vruntime`。CFS 找到在树中 `vruntime` 最小的节点(最左侧的叶子节点)。时间复杂度 O(logN) 。

增：
当通过 `fork` 调用创建进程时 和 进程变为可运行状态时，CFS 会将进程插入到 rbtree 中。Linux 中的 `enqueue_entity()` 实现了这一功能。由于平衡二叉树的性质，如果待插入节点键值小于当前键值，则往左分支走，反之。因此一旦有一次走过右分支，则可以设置最左分支叶子节点 `leftmost=0`。否则可以让 `leftmost=1` 表示可以更新最左节点。使用 `rb_leftmost` 指向最终被插入的进程，就算是更新缓存好了。

删：
当 进程堵塞 或 进程变为不可运行态 或 终止时，发生删除进程的操作。`rbtree` 实现了 `rb_erase()` 函数，可以完成删除操作。此外还需要更新 `rb_leftmost` 缓存，使用 `rb_next()` 找到谁是下一个节点，然后更新最新的最左节点信息到 `rb_leftmost` 上。
```

#### 4.5.3 调度器入口

```markdown
调度器的入口点函数是 `schedule()`, 它负责选择哪个进程可以运行，何时将其投入运行。`schedule()` 通常需要和 具体的调度类 相关联，`schedule()` 会调用 `pick_next_task()`，该函数会以优先级为顺序，从高到低检查每一个调度类，从最高优先级的调度类，选择最高优先级的进程，然后返回。

另外一提 CFS 是普通进程的调度类，系统运行的绝大多数进程都是普通进程。
```

#### 4.5.4 睡眠和唤醒

```markdown
休眠：
休眠（被阻塞）的进程处于一个特殊的不可执行的状态。引起休眠的原因有很多，但肯定都是为了等待一些事件。无论是什么原因，都是进程把自己标记称休眠状态，从可执行红黑树中移出，放入等待队列中，然后调用 `schedule()` 选择和执行下一个进程。

唤醒：
进程会被设置为可执行状态，从等待队列中移出来，然后移入可执行红黑树中。

在 Linux 中和进程休眠有两种进程状态：TASK_INTERRUPTIBLE 和 TASK_UNINTERRUPTIBLE。它们的唯一区别就是 TASK_UNINTERRUPTIBLE 的进程会忽略信号，处于 TASK_INTERRUPTIBLE 状态的进程如果接收到一个信号，会被提前唤醒并响应该信号。
```

**等待队列**

```markdown
等待队列是由等待某些事件发生的进程组成的简单链表。内核中用 `wake_queue_head_t` 代表等待队列。创建等待队列有两种方法：`DECLARE_WAITQUEUE()` 静态创建 和 `init_waitqueue_head()` 动态创建。进程把自己放入等待队列中并设置成不可执行状态，当与等待队列相关的发生的时候，队列上的进程会被唤醒。
```

**唤醒**

```markdown
唤醒操作通过 `wake_up()` 进行, 它会唤醒指定的等待队列上的所有进程。它会调用 `try_to_wake_up()`，该函数会将进程设置为 `TASK_RUNNING` 状态，调用 `enqueue_task()` 将进程再放入 rbtree 中。如果说被唤醒的进程优先级比当前正在执行的进程优先级更高，还要设置 `need_resched` 标志。通常哪段代码促使等待条件达成，它就要负责随后调用 `wake_up()`。
```

### 4.6 抢占 和 上下文切换

```markdown
上下文切换：
从一个可执行进程切换到另一个可执行进程。由 `context_switch()` 负责处理，每当一个新的进程被选出来准备投入运行的时候，`schedule()` 就会调用该函数。主要做了两项基本的操作：
1. `switch_mm()` 把虚拟内存从上一个进程映射切换到新进程中。
2. `switch_to()` 负责从上一个进程的处理器状态切换到新进程的处理器状态。包括 保存、恢复栈信息、寄存器信息。

抢占:

```






































































