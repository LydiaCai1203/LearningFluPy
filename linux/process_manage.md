## 第三章：进程管理

### 3.1 进程

#### 3.1.1 进程 和 线程

```markdown
进程：
进程就是处于执行期的程序。包括但不限于一段可执行的程序代码，还包括其他资源：打开的文件、挂起的信号、内核内部数据、处理器状态，一个或多个具有内存映射的内存地址空间及一个或多个执行线程，还包括用来存放全局变量的数据段等。

线程：
是进程中活动的对象。每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器。内核调度的对象是线程，而不是进程。在传统的 Unix 中，一个进程只包含一个线程。Linux 的线程实现非常特别：它对线程和进程并不会特别区分。对 Linux 而言，线程只不过是一种特殊的进程罢了。
```

#### 3.1.2 进程的两种虚拟机制：虚拟处理器 和 虚拟内存

```markdown
虚拟处理器：
可能是许多进程在分享一个处理器，虚拟处理器让进程觉得自己在独享处理器。

虚拟内存：
让进程在分配和管理内存时觉得自己拥有了所有的内存资源。
```

#### 3.1.3 进程相关的几个系统调用

```markdown
1. fork() 复制一个现有进程来创建一个全新的进程。内部由 clone() 实现的。
2. exec() 创建新的地址空间，并且把新的程序载入其中。
3. exit() 退出执行。会退出进程并将其占用的资源释放掉。
4. wait4() 父进程可以调用 wait4() 来查询子进程是否终结，这使得进程拥有了等待特定进程执行完毕的能力。
```

### 3.2 进程描述符及任务结构

```markdown
内核把进程的列表存放在任务队列(双向链表)中。链表中的每一项都是类型为 task_struct(进程描述符) 的结构。进程描述符包含了一个具体进程的所有信息，包括了：进程打开的文件、进程的地址空间、挂起的信号、进程的状态，其他更多的信息。
```

#### 3.2.1 分配进程描述符

```markdown
Linux 通过 slab 分配器分配 task_struct 结构，这样能够达到对象复用和缓存着色(cache coloring) 的目的。通过预先分配 task_struct 和 重复使用，可以避免动态分配和释放带来的资源消耗。这就是第一章说的 Unix 的一个特点就是进程创建迅速。
```

#### 3.2.2 进程描述符的存放

```markdown
内核通过一个唯一的 PID 来标识每个进程。PID 是一个 int 类型的数。为了与老版本的 Unix 和 Linux 兼容，PID 的最大默认值设置为 32768。内核中把每个进程的 PID 存放在它们各自的进程描述符中。

PID 的最大值也就以为系统中允许同时存在的进程的最大数目。这个值可以通过修改 /proc/sys/kernel/pid_max 来提高上限。

在内核中，访问任务通常需要获得指向其 task_struct 的指针。实际上内核中大部分处理进程的代码都是直接通过 task_struct 来进行的。有的硬件体系结构可以拿出一个专门的寄存器存放指向当前进程的 task_struct 的指针。有的像 x86 这样的体系结构，只能在内核栈的尾端创建 thread_info 结构，通过计算偏移来间接地查找 task_truct 结构。
```

#### 3.2.3 进程状态

```markdown
进程描述符中的 state 域描述了进程的当前状态。有：

TASK_CREATED
TASK_READY
TASK_RUNNING
TASK_WAIT
TASK_STOPPED
```

#### 3.2.4 设置当前进程状态

```markdown
set_task_state(task, state) 等价于 task -> state = state
```

#### 3.2.5 进程上下文

```markdown
可执行代码会从一个可执行文件载入到进程的地址空间来执行。一般程序在用户空间执行，当一个程序执行了系统调用，或是触发了某个异常，它就会陷入内核空间。即，内核 "代表进程执行" 并处于进程上下文中。除非在此间隙中有更高优先级的进程需要执行并由调度器作出相应调整，否在在内核退出时，程序恢复然后在用户空间继续进行。

系统调用和异常处理程序是对内核明确定义的接口。进程只有通过这些接口才能陷入内核执行，对内核的所有访问都必须通过这些接口。
```

*中断上下文*

```markdown
在中断上下文中，系统不能代表进程执行，而是执行一个中断处理程序，不会有进程去干扰这些中断处理程序，所以此时不存在进程上下文。
```

#### 3.2.6 进程家族树

```markdown
Linux 中所有的进程都是 PID=1 的 init 进程的后代。内核在系统启动的最后阶段启动 init 进程。该进程读取系统的初始化脚本并且执行其他的相关程序，最后完成系统启动的整个过程。

进程间的关系存放在 进程描述符(task_struct) 中。每个 task_struct 都包含一个指向其父进程 task_struct 的 parent 指针，还包含一个 children 的子进程链表。
```

### 3.3 进程创建

```markdown
Unix 的进程创建分解在两个单独的函数中：
1. fork() - 通过拷贝当前进程创建一个子进程。子进程和父进程的区别仅仅在于 PID，PPID(Parent PID) 和 某些资源 和 统计量（挂起的信号）。
2. exec() - 负责读取可执行文件并将其载入地址空间然后开始运行。
```

#### 3.3.1 写时拷贝

```markdown
传统 fork 缺点：
传统的 fork() 直接把所有的资源复制给新创建的进程，这种实现过于简单并且效率低下，因为它拷贝的数据也许并不共享，如果新进程打算立即执行一个新的映像，所有的拷贝都将前功尽弃。

Linux fork 改进：
采用了写时拷贝(copy-on_write)页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父子进程共享(只读共享)同一个拷贝。只有在需要写入的时候，数据才会被复制，从而使得各个进程都拥有各自的拷贝。这种技术使得地址空间上的页的拷贝被推迟到实际发生写入的时候才会进行，在页根本不会写入的情况下，它们就无须复制了。

fork() 的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。
一般情况下，进程创建后会马上运行一个可执行文件，这种优化避免拷贝大量不会用的数据，由于 Unix 强调进程快速执行的能力，这个优化非常重要。
```

#### 3.3.2 fork()

```markdown
fork() 内部通过调用 clone() 实现。这个调用通过一系列的参数标志来指明父子进程需要共享的资源。fork()、vfork()、_clone() 都是根据各自需要的参数标志去调用 clone()，然后由 clone() 去调用 do_fork()。

过程描述：
1. do_fork() 完成创建中的大部分工作。
2. do_fork() 内部运行 copy_process()， 作用是让进程开始运行。
3. 拷贝 task_struct、tread_info 等信息，子进程和父进程的进程描述符是一样的。
4. 子进程会修改一些自己的参数来与父进程区分开来。然后会被分到一个 pid。
5. 开始处理文件资源(拷贝、共享)，进程地址空间、命名空间等等。这些资源一般是给定进程的所有线程共享。
6. copy_process() 返回一个指向子进程的指针，如果成功返回，新创建的子进程会被唤醒，并被投入运行。内核会有意让子进程先运行，因为子进程会马上调用 exec()，这样可以避免 copy-on-write 的额外开销。
```

#### 3.3.3 vfork()

```markdown
vfork() 和 fork() 的区别就是不会拷贝父进程的页表项。子进程作为父进程的一个单独线程在它的地址空间运行，父进程会被阻塞，直到子进程退出或执行 exec()。子进程不能向地址空间写入。自从 fork() 引入了 copy-on-write 机制，vfork() 的好处就只有不拷贝父进程的页表项了。

由于 vfork() 的语义非常微妙，理想情况下，系统最好不要调用 vfork()
```

### 3.4 线程在 Linux 中的实现：

```markdown
线程机制提供了在同一程序内共享内存地址空间的一组线程。这些线程可以共享打开的文件和其它资源。线程机制支持并发程序设计技术，在多处理器系统上，它也能保证真正的并行运行。

从 Linux 内核的角度说，并没有线程的概念。Linux 把所有的线程都当作进程来实现。线程仅仅被视为一个与其他进程共享某些资源的进程。每个线程都有自己唯一隶属于自己的 task_struct，所以在内核中，它看起来就像是一个普通的进程，只不过线程与其他一些进程共享某些资源，如地址空间。

对于 Linux 来说，它只是一种进程间共享资源的手段，比如现在有一个包含四个线程的进程，Linux 就是创建四个进程，分配四个 task_struct 结构。建立这四个进程时，指定它们共享某些资源，这是相当高雅的做法。
```

#### 3.4.1 创建线程

+ 线程的创建：

`clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND, 0)`

+ 普通的 fork 实现：

`clone(SIGCHLD, 0)`

+ 普通的 vfork 实现：

`clone(CLONE_VFORK | CLONE_VM | SIGCHLD, 0)`

传递给 clone 的参数标志决定了 **新创建进程的行为方式**，**父子进程之间共享的资源种类**。

| 参数标志          | 含义                   |
|:-------------:|:--------------------:|
| CLONE_FILES   | 父子进程共享打开的文件          |
| CLONE_FS      | 父子进程共享文件系统信息         |
| CLONE_VM      | 父子进程共享地址空间           |
| CLONE_SIGHAND | 父子进程共享信号处理函数以及被阻断的信号 |

#### 3.4.2 内核线程

```markdown
内核经常需要在后台执行一些操作(flush)。这种任务可以通过 内核线程(kernel thread) 来完成，内核线程是独立运行在内核空间的标准进程。 kernel thread 和 普通进程 的区别在于内核线程没有独立的地址空间，只在内核空间运行，从来不会切换到用户空间去。它可以被调度，也可以被抢占。

`ps -ef` 可以看到内核线程。内核线程只能由内核线程创建
`kthread_create` 内核线程使用该方法创建新的内核线程, 内部调用 clone(), 创建好内核线程是处于不可运行的状态。
`thread_run()` 内部会调用 `wake_up_process()来让进程运行起来。
`do_exit()` 或 `kthread_stop()` 内核线程启动后会一直运行直到调用这个函数退出。
```

### 3.5 进程终结

```markdown
进程终结时，内核要释放它所占有的资源并通知父进程。进程终结可能是主动引起(比如主动调用 do_exit())，也可能是被动引起的(收到某些信号)。不管如何终结，大部分要靠 do_exit() 来完成。
1. 释放所占有的资源。
2. 发送信号给父进程，然后给子进程找养父(其他进程或者是 init 进程)，并且把自己的进程状态置为 EXIT_ZOMBIE。
3. do_exit() 调用 schedule() 切换到新的进程，因为处于 EXIT_ZOMBIE 状态，所以该进程不会再被调度了。

这时，该调用 exit() 的进程相关联的资源被释放掉了，进程也不可以运行了，还占用的内存的内核栈、thread_info 结构、task_struct 结构。此时进程存在的唯一目的就是向他的父进程提供信息。父进程检索到信息后，通知内核那是无关的信息，然后进程所持有的剩余内存会被释放，归还给系统使用。
```

#### 3.5.1 删除进程描述符

```markdown
在调用了 do_exit() 之后，尽管线程已经僵死不能再运行，系统还保留了它的进程描述符。目的就是为了让系统有办法在子进程终结之后仍能获取它的信息。因此进程终结时所需的清理工作和进程描述符的删除被分开执行。在父进程获得已经终结的子进程的信息后，通知内核它并不关注那些信息之后，子进程的 task_struct() 才会被释放。

主进程调用 wait() 以后阻塞，wait() 内部调用的是 wait4(), 直到父进程的其中一个子进程退出，此时 wait() 会返回该子进程的 PID。此外调用该函数时传入的指针，会包含子进程退出时的退出代码。

1. release_task() 释放 thread_info()、task_struct()。可能还会有通知的作用。
```

#### 3.5.2 孤儿进程造成的进退维谷

```markdown
如果父进程在子进程之前退出，必须有机制保证子进程找到一个新的父亲。否则这些孤儿进程就会在退出的时候永远处于僵死状态，白白地耗费内存。

解决方法是在当前进程所在的线程组内的其他进程。如果线程组内没有其他的进程了，它就找 init 进程来当爸爸。找到以后遍历所有的子进程，为它们设置新的父进程。init 进程会例行调用 wait() 来检查其子进程，清除所有与其相关的僵死进程。
```


































































































