## 第三章：进程管理

### 3.1 进程

#### 3.1.1 进程 和 线程

```markdown
进程：
进程就是处于执行期的程序。包括但不限于一段可执行的程序代码，还包括其他资源：打开的文件、挂起的信号、内核内部数据、处理器状态，一个或多个具有内存映射的内存地址空间及一个或多个执行线程，还包括用来存放全局变量的数据段等。

线程：
是进程中活动的对象。每个线程都拥有一个独立的程序计数器、进程栈和一组进程寄存器。内核调度的对象是线程，而不是进程。在传统的 Unix 中，一个进程只包含一个线程。Linux 的线程实现非常特别：它对线程和进程并不会特别区分。对 Linux 而言，线程只不过是一种特殊的进程罢了。
```

#### 3.1.2 进程的两种虚拟机制：虚拟处理器 和 虚拟内存

```markdown
虚拟处理器：
可能是许多进程在分享一个处理器，虚拟处理器让进程觉得自己在独享处理器。

虚拟内存：
让进程在分配和管理内存时觉得自己拥有了所有的内存资源。
```

#### 3.1.3 进程相关的几个系统调用

```markdown
1. fork() 复制一个现有进程来创建一个全新的进程。内部由 clone() 实现的。
2. exec() 创建新的地址空间，并且把新的程序载入其中。
3. exit() 退出执行。会退出进程并将其占用的资源释放掉。
4. wait4() 父进程可以调用 wait4() 来查询子进程是否终结，这使得进程拥有了等待特定进程执行完毕的能力。
```

### 3.2 进程描述符及任务结构

```markdown
内核把进程的列表存放在任务队列(双向链表)中。链表中的每一项都是类型为 task_struct(进程描述符) 的结构。进程描述符包含了一个具体进程的所有信息，包括了：进程打开的文件、进程的地址空间、挂起的信号、进程的状态，其他更多的信息。
```

#### 3.2.1 分配进程描述符

```markdown
Linux 通过 slab 分配器分配 task_struct 结构，这样能够达到对象复用和缓存着色(cache coloring) 的目的。通过预先分配 task_struct 和 重复使用，可以避免动态分配和释放带来的资源消耗。这就是第一章说的 Unix 的一个特点就是进程创建迅速。
```

#### 3.2.2 进程描述符的存放

```markdown
内核通过一个唯一的 PID 来标识每个进程。PID 是一个 int 类型的数。为了与老版本的 Unix 和 Linux 兼容，PID 的最大默认值设置为 32768。内核中把每个进程的 PID 存放在它们各自的进程描述符中。

PID 的最大值也就以为系统中允许同时存在的进程的最大数目。这个值可以通过修改 /proc/sys/kernel/pid_max 来提高上限。

在内核中，访问任务通常需要获得指向其 task_struct 的指针。实际上内核中大部分处理进程的代码都是直接通过 task_struct 来进行的。有的硬件体系结构可以拿出一个专门的寄存器存放指向当前进程的 task_struct 的指针。有的像 x86 这样的体系结构，只能在内核栈的尾端创建 thread_info 结构，通过计算偏移来间接地查找 task_truct 结构。
```

#### 3.2.3 进程状态

```markdown
进程描述符中的 state 域描述了进程的当前状态。有：

TASK_CREATED
TASK_READY
TASK_RUNNING
TASK_WAIT
TASK_STOPPED
```

#### 3.2.4 设置当前进程状态

```markdown
set_task_state(task, state) 等价于 task -> state = state
```

#### 3.2.5 进程上下文

```markdown
可执行代码会从一个可执行文件载入到进程的地址空间来执行。一般程序在用户空间执行，当一个程序执行了系统调用，或是出发了某个异常，它就会陷入内核空间。即，内核 "代表进程执行" 并处于进程上下文中。除非在此间隙中有更高优先级的进程需要执行并由调度器作出相应调整，否在在内核退出时，程序恢复然后在用户空间继续进行。

系统调用和异常处理程序是对内核明确定义的接口。进程只有通过这些接口才能陷入内核执行，对内核的所有访问都必须通过这些接口。
```

*中断上下文*

```markdown
在中断上下文中，系统不能代表进程执行，而是执行一个中断处理程序，不会有进程去干扰这些中断处理程序，所以此时不存在进程上下文。
```

#### 3.2.6 进程家族树

```markdown
Linux 中所有的进程都是 PID=1 的 init 进程的后代。内核在系统启动的最后阶段启动 init 进程。该进程读取系统的初始化脚本并且执行其他的相关程序，最后完成系统启动的整个过程。

进程间的关系存放在 进程描述符(task_struct) 中。每个 task_struct 都包含一个指向其父进程 task_struct 的 parent 指针，还包含一个 children 的子进程链表。
```

### 3.3 进程创建

```markdown
Unix 的进程创建分解在两个单独的函数中：
1. fork() - 通过拷贝当前进程创建一个子进程。子进程和父进程的区别仅仅在于 PID，PPID(Parent PID) 和 某些资源 和 统计量（挂起的信号）。
2. exec() - 负责读取可执行文件并将其载入地址空间然后开始运行。
```

#### 3.3.1 写时拷贝

```markdown
传统 fork 缺点：
传统的 fork() 直接把所有的资源复制给新创建的进程，这种实现过于简单并且效率低下，因为它拷贝的数据也许并不共享，如果新进程打算立即执行一个新的映像，所有的拷贝都将前功尽弃。

Linux fork 改进：
采用了写时拷贝(copy-on_write)页实现。写时拷贝是一种可以推迟甚至免除拷贝数据的技术。内核此时并不复制整个进程地址空间，而是让父子进程共享(只读共享)同一个拷贝。只有在需要写入的时候，数据才会被复制，从而使得各个进程都拥有各自的拷贝。这种技术使得地址空间上的页的拷贝被推迟到实际发生写入的时候才会进行，在页根本不会写入的情况下，它们就无须复制了。

fork() 的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。
一般情况下，进程创建后会马上运行一个可执行文件，这种优化避免拷贝大量不会用的数据，由于 Unix 强调进程快速执行的能力，这个优化非常重要。
```

#### 3.3.2 fork()

```markdown

```
