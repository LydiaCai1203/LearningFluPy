## 第五章：系统调用

```markdown
内核提供了用户进程与内核进行交互的一组接口。这些接口让应用程序 受限地 访问硬件设备，提供了创建新进程 与 进程间通信的机制，提供了申请操作系统其它资源的能力。这些接口的存在主要是为了保证系统的稳定可靠。
```

### 5.1 与内核通信

```markdown
系统调用 在用户空间和硬件设备之间添加了一个中间层。作用如下：

1. 为用户空间提供了一种硬件的抽象接口。(当应用程序需要读文件时，应用程序可以不管磁盘类型和介质，甚至不用去管文件所在的文件系统到底是哪种类型)

2. 系统调用 保证了系统的稳定和安全。(内核可以基于权限、用户类型和其它的一些规则对需要进行的访问进行裁决，这样可以避免应用程序不正确地使用硬件设备，窃取其它进程的资源，做出危害系统的事情)

3. 如果应用程序可以随意访问硬件而内核又对此一无所知的话，几乎无法实现多任务和虚拟内存。也不可能实现良好的稳定性和安全性。
```

### 5.2 API、POSIX 和 C 库

```markdown
API:
指应用程序通过在用户空间实现的应用编程接口(API)而不是直接通过 系统调用 来编程。一个 API 可以对应一个或者多个 系统调用，完全不使用 系统调用 也没有问题。API 可以在不同的操作系统上实现，给应用程序提供完全相同的接口，而它们本身的实现可能迥异。

POSIX(Portable Operating System Interface of UNIX):
POSIX 是一种标准，由 IEEE 的一组标准组成的。定义了操作系统应该为应用程序提供的接口标准。POSIX 期望在源代码级别的软件可移植性，也就是说一个为了 POSIX 操作系统编写的应用程序，在其它的 POSIX 操作系统上也一样可以运行。

C库：
Linux 的 C库 实现了 Unix 系统的主要 API, 包括标准 C库 函数 和 系统调用。所有的 C程序 都可以使用 C库，由于 C语言 本身的特点，其它语言也可以很方便地封装它们使用。

关系：
调用 printf() -> C库中的 printf() -> C库中的 write() -> write() 系统调用
  [应用程序]                    [C 库]                      [内核]
```

### 5.3 系统调用

```markdown
访问系统调用通常需要通过 C库 中定义的函数调用来进行。这些系统调用可能会产生一些副作用(会使系统的状态发生某种变化)。系统调用在出现错误的时候，C库 会把错误码写入 errno 全局变量中，可以通过 `perror()` 库函数把该变量翻译成用户可以理解的错误字符串。

一个系统调用的定义：
`asmlinkage long sys_getpid(void)`   
`asmkinkage` 是一个编译指令，通知编译器仅从栈中提取该函数的参数。其次在内核空间返回 long, 但是在用户空间返回 int。这样做是为了保证 32bit 和 64bit 系统的兼容。

tips:
`getpid()` 返回的是 `tgid`(线程组ID)。因为对于普通进程来说，tgid 等于 pid。对于线程来说，同一个线程组内的所有线程的 tgid 都相等，所以返回 tgid 适用于进程和线程。

```

#### 5.3.1 系统调用号

```markdown
在 Linux 中，每个系统调用都被赋予一个系统调用号。当用户空间的进程执行一个系统调用的时候，这个系统调用号就用来指明到底是要执行哪个系统调用。进程并不会提及系统调用的名称。

系统调用号一旦分配，不可以变更，否则编译好的应用程序就会崩溃。此外如果一个系统调用被删除，它所占用的系统调用号也不允许被回收利用。否则以前编译过的代码使用的是这个系统调用号，但是实际调用的确实另一个系统调用。应该使用 `sys_ni_syscall()`，这个函数除了返回 `-ENOSYS` 之外不会做任何其它的工作，这个错误号就是专门针对无效的系统调用设置的。

内核记录了系统调用表中所有已注册过的系统调用的列表，存储在 `sys_call_table` 中。这个表为每一个有效的系统调用指定了唯一的系统调用号。
```

### 5.3.2 系统调用的性能

```markdown
Linux 的 syscall 比其它操作系统执行的要快。原因有二：
1. Linux 的上下文切换时间很短, 进出内核都被优化地简洁高效。
2. syscall 处理程序 和 syscall 都非常的简洁。
```

### 5.4 系统调用处理程序

```markdown
用户空间的程序是无法直接执行内核代码的，因此不能直接调用内核空间的函数。因为内核驻留在 受保护的 地址空间上。因此应用程序会告诉内核自己需要执行一个系统调用，希望系统切换到内核态，这样内核就可以代表应用程序在内核空间执行系统调用。

通知内核的机制：
通过引发一个异常促使系统切换到内核态去执行异常处理程序。此时的异常处理程序实际上就是 系统调用处理程序。在 x86 系统上预定义的软中断的中断号是 128, 对应一条中断指令，这条指令会触发一个异常导致系统切换到内核态，然后执行第 128 号异常处理程序，该程序正是系统调用处理程序。这个处理程序的名字叫做 `system_call()`
```

#### 5.4.1 指定恰当的系统调用

```markdown
在 x86 上，系统调用号是通过 eax 寄存器传递给内核的。因此在陷入内核态之前，用户空间就把对于的系统调用号放入 eax 中。`system_call()` 通过将给定的系统调用号与 `NR_syscalls` 做比较来检查其有效性，如果大于等于 `NR_syscalls`, 函数就返回 `-ENOSYS`, 否则会执行相应的系统调用 `call *sys_call_table(,%rax, 8)`。

过程如下：
read() -> read() -> system_call() -> sys_read() 
 应用       C库      系统调用处理程序     系统调用
   用 户 空 间                   内 核 空 间
```

#### 5.4.2 参数传递

```markdown
那么除了系统调用号以外的其它参数如何传递？

最简单的方式就是把这些参数也放在寄存器里，在 x86-32 的系统上，ebx、ecx、edx、esi、edi 按照顺序存放前 5 个参数。因为 6 个及以上的参数不多见。另外需要一个单独的寄存器存放指向所有这些参数在用户空间地址的指针。返回给用户空间的值同样放在寄存器(eax)里。
```

### 5.5 系统调用的实现

#### 5.5.1 实现系统调用

```markdown
1. Linux 中倡导每个系统调用有一个明确的用途，不倡导多用途系统调用。
2. 系统调用的参数应尽可能少、返回值、错误码，接口实现力求简洁。
3. 系统调用的设计越通用越好，考虑可移植性。不要假设系统调用现在会怎么用，将来也会怎么用。
```

#### 5.5.2 参数验证

```markdown
系统调用必须仔细检查参数是否合法有效，因为在内核空间执行，需要考虑系统的安全和稳定性。比如：
1. 文件 I/O 相关的系统调用：检查文件描述符是否有效。
2. 进程相关的系统调用：检查提供的 PID 是否有效。
3. 最重要的是要检查用户提供的指针是否有效:
  a. 指针指向的内存区域属于用户空间。
  b. 指针指向的内存区域在进程的地址空间里。 
  c. 进程所做操作不能绕过内存访问限制。
  内核提供了两个方法来完成必须的检查和内核空间与用户空间之间的数据来回拷贝`copy_to_user()` 和 `copy_from_user()` 来实现。执行成功这两个函数会返回 0。具体含义不记录了。需要了解再查阅。
```

### 5.6 系统调用上下文

```markdown
内核在执行系统调用时处于进程上下文。`current` 指针指向当前任务，即引发系统调用的那个进程。在进程上下文中：1.内核可以休眠, 如调用 `schedule()` 时。2.可以被抢占。当系统调用  返回时，控制权仍然在 `system_call()` 中，它最终会负责切换到用户空间，并让用户进程继续执行下去。
```

#### 5.6.1 绑定一个系统调用的最后步骤

```markdown
当编写完一个系统调用后，还需要将其注册成为一个正式的系统调用。
1. 在系统调用表的最后加入一个表项。从 0 开始算起，系统调用在该表中的位置就是它的系统调用号。
2. 系统调用号都必须定义于 <asm/unistd.h> 中。
3. 系统调用必须被编译进内核映像，不能被编译成模块。
```

```c
/* 第一步 */
ENTRY(sys_call_table)
    .long sys_restart_syscall
    .long sys_exit
    .long sys_read
    ...
    .long sys_foo       /*我们写的这个系统调用*/
```

```c
/* 第二步 <asm/unistd.h> */
#define _NR_restart_syscall 0
#define _NR_exit            1
#define _NR_read            2
...
#define _NR_foo            138
```

```c
/* 第三步 把这个例子放入 kernel/sys.c 中*/
#include <asm/page.h>

asmlinkage long sys_foo(void):
{   
    // 返回每个进程的内核栈大小
    return  THREAD_SIZE
}
```

#### 5.6.2 从用户空间访问系统调用具体步骤

```markdown
通常，系统调用靠 C库 支持，用户程序通过包含标准头文件与 C库 连接，这样就可以使用系统调用了。上面说过是无法直接在。Linux 本身提供了一组宏，用于直接对 系统调用 进行访问。它会设置好寄存器并调用陷入指令，这些宏是 `_syscalln()`, n 的范围是 [0, 6]，代表要传递给系统调用的参数个数。

例子：
某系统调用：
`long open(const char *filename, int flags, int mode)`
不靠库支持，直接调用此系统调用的宏的形式为：
`#define NR_open 5`
`_syscall3(long, open, const char*, filename, int, flags, int, mode）
对于每个宏来说，都有 `2+2*n` 个参数，第一个参数对应系统调用的返回值类型，第二个参数是系统调用的名称。系统调用处理程序会将 系统调用号 和 参数 压入寄存器。
```

#### 5.6.3 为什么不通过系统调用的方式实现

```markdown
不提倡建立新的系统调用，因为：
1. 你需要一个系统调用号，这需要一个内核处于开发版本时由官方分配给你。
2. 系统调用被加入稳定内核后就被固化了，为了避免应用程序崩溃，它的接口不允许做改动。
3. 需要将系统调用分别注册到每个需要支持的体系中去。
4. 在脚本中不支持直接调用系统调用，如果仅仅是为了进行信息交换，没必要。

下面说了一些替代新建系统调用的方法，但是我没记录。以后再回过头看吧。
```

![](/Users/caiqingjing/project/private/leetcode-practice/statics/sys_call_mindnode.png)
















































































