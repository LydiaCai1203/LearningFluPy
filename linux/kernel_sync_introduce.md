## 第九章：内核同步介绍

### 9.1 临界区和竞争条件

```markdown
临界区：
访问和操作共享数据的代码段。为了避免在临界区中并发访问，编程者要保证临界区代码原子地执行。

竞争条件：
如果两个执行线程有可能处于同一个临界区中同时执行，就称其为竞争条件。出现这种情况代表有 bug。避免并发和防止竞争条件成为同步。
```

### 9.2 加锁

```markdown
有一些操作 `i++;` 处理器会从物理上将这条指令变为原子指令。内核也提供了一组实现这些原子操作的接口。但是对于另外一些复杂的场景，无法使用原子指令解决，只能采用锁机制来保证其原子性。获取锁的线程才有资格执行临界区。

Linux 自身实现了几种不同的锁机制，这些锁机制的区别在于：当锁已经被其它线程持有，因而不可用时的行为表现。比如：1. 执行忙等待(不断检测锁状态，直到锁变为可用) 2. 使当前的任务睡眠直到锁可用为止。
```

#### 9.2.1 造成并发执行的原因

```markdown
用户空间之所以需要同步，是因为用户程序会被调度程序抢占与重新调度。调度程序可以随时选择其它更高优先级的进程到处理器上执行。也就是说，会使得一个程序正处于临界区时，被非自愿地抢占了。如果新调度的进程随后进入同一临界区(比如共享内存，或向同一文件描述符中写入)。前后两个进程之间会出现竞争条件。

在内核中还有其它导致并发的原因：
  1. 中断、软中断、tasklet。
  2. 内核抢占。
* 3. 睡眠及用户空间同步：在内核执行的进程如果睡眠了，就会唤醒调度程序，调度程序会调度另一个新的用户进程执行。
  4. 对称多处理器。
```

```markdown
中断安全代码：在中断处理程序中能避免并发访问的安全代码
SMP 安全代码：在对称多处理的机器中避免并发访问的安全代码
抢占安全代码：在内核抢占时能避免并发访问的代码
```

#### 9.2.2 了解保护些什么

```markdown
执行线程的局部数据仅仅被它本身访问，显然不需要被保护。因为它们独立存在于执行线程的栈中。
动态分配的数据结构，其地址仅存放在堆栈中。那么什么需要被保护？某些数据能被其它任何线程看到的时候，就需要给这些数据加锁。

记住：是给数据加锁，而非代码。
```

#### 9.3 死锁

```markdown
死锁产生的条件：
1. 一个或多个执行线程 && 一个或多个共享资源
2. 每个线程都在等待其中的一个资源
3. 但是所有的资源都已经被占用
```

**自死锁**

```markdown
如果一个执行线程去试图获取一个自己已经持有的锁，它将不得不等待锁的释放。有些内核提供了 递归锁 解决自私锁的问题，就是一个锁可以被多次获取。但是 Linux 没有提供，因为会使得代码变得杂乱无章。
```

ABBA 死锁

```markdown
线程 1 持有锁 A，等待锁 B。线程 2 持有锁 B，等待锁 A。
```

**预防死锁**

```markdown
1. 按照顺序加锁，尤其是使用潜逃锁时，这样可以避免拥抱类型的死锁。
2. 防止发生饥饿，即当死锁放生时，线程是否一定要一直等待下去。
3. 不要重复请求同一个锁。
4. 设计应力求简单。
```

### 9.5 争用和扩展性

```markdown
锁的争用，简称争用，指当前锁正在被占用时，有其它线程试图获得该锁，该锁处于高度争用的状态。被高度争用的锁会成为系统的瓶颈。
```

```markdown
缓解锁争用问题可以采取细化锁粒度。所谓的锁粒度，指的是锁保护的数据的规模，锁粒度越小，所保护的数据也就越精细。所谓的可扩展性就是指，锁粒度过粗可能会导致锁争用，但是锁粒度过细，也会导致在小型机上运行效率不佳，因为小型机可能不会有这么多并发。且会加大系统的开销，造成浪费。

因此初期加锁方案应该力求简单，仅当需要时再进一步细化加锁方案，精髓就在于力求简单。
```
















































































