# 第三讲：事务隔离

- [隔离性和隔离级别](#隔离性和隔离级别)
    - [事务的四个特性](#事务的四个特性)
    - [事务会出现的三种问题](#事务会出现的三种问题)
    - [事务的四种隔离级别](#事务的四种隔离级别)
        - [读未提交(read uncommitted)](#读未提交(read-uncommitted))
        - [读已提交(read committed)](#读已提交(read-committed))
        - [可重复读(read repeatable)](#可重复读(read-repeatable))
        - [串行化(serializable)](#串行化(serializable))
    - [隔离级别再解释](#隔离级别再解释)
- [事务隔离的实现](#事务隔离的实现)
    - [read-view](#read-view)
- [不建议使用长事务(持续时间超过60s)](#不建议使用长事务(持续时间超过60s))
- [事务的启动方式](#事务的启动方式)
    - [显示启动事务语句](#显示启动事务语句)
    - [set autocommit=0](#set-autocommit=0)

------------------------------------
[TOC]
## 隔离性和隔离级别
#### 事务的四个特性
+ 原子性
+ 一致性
+ 隔离性
+ 持久性

#### 事务会出现的三种问题
+ 脏读
+ 不可重复读
+ 幻读

#### 事务的四种隔离级别
##### 读未提交(read uncommitted)
    一个事务在未提交的时候，它所做的变更就可以被其它的事务所看见
##### 读已提交(read committed)
    一个事务已经提交的时候，它所做的变更才能被其它的事务所看见
##### 可重复读(read repeatable)
    一个事务在执行过程中看到的数据，总是跟这个事务在启动的时候看到的数据是一致的。当然在可重复读的隔离级别下，为提交的事务所做的变更对其它的事务也是不可见的。
##### 串行化(serializable)
    对于同一行记录，写会加上写锁，读会加上读锁，出现读写锁冲突的时候，后访问的事务必须等待前一个事务结束才可以访问。

#### 隔离级别再解释

![1](https://github.com/LydiaCai1203/leetcode-practice/blob/master/statics/%E4%BA%8B%E5%8A%A1.jpg)

+ **read uncommitted**
    + V1=2；V2=2；V3=2；
    + 原理
        + 直接返回的是记录上的最新值
    + 别人改数据的事务尚未提交，我在我的事务中也能读到
+ **read committed**
    + V1=1；V2=2；V3=2；
    + 原理
        + 每个SQL语句开始的时候创建视图，整个事务期间都在使用这个视图
    + 别人改数据的事务尚未提交，我在我的事务中不能读到
+ **read repeatable**
    + V1=1；V2=1；V3=2；
    + 因为要遵循事务在执行的过程中，所读到的数据是一样的
    + 原理
        + 视图会在事务启动的时候开始创建，整个事务期间都在使用这个视图
    + 别人改数据的事务尚未提交，我在我的事务中也不会去读
+ **serializable**
    + V1=1；V2=1；V3=2；
    + 在事务B执行更新操作的时候，被写锁锁住了。直到事务A提交完成了以后，事务B才会继续执行
    + 原理
        + 采用直接加锁的方式来避免并行访问，但是要注意，读读操作是可以并行的
    + 我的事务尚未提交的话，别人就别想改数据

## 事务隔离的实现
    在MySQL中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上面的最新值都是可以通过回滚操作得到前一个状态的值的。也就是说，如果现在有一个字段，被更新的顺序是1->2->3->4。然后回滚字段里面的记录就是[2->1](read-view: A)->[3->2](read-view: B)->[4->3]->当前值为4(read-view:C).

#### read-view 
+ 不同时刻事务的启动会有不同的read-view，在read-view A 里面，如果要得到value=1，就必须要将当前值4依次回滚得到。
+ 即使有另一个事务将4改成5，这个事务read-viewA,B,C对应的事务也是不会有冲突的。
+ 系统会自己判断，当然为事务不再需要这些回滚日志的时候，就会自动删除
+ 所以同一条记录在数据库中有多个版本，这就是数据库的多版本并发控制(MVCC)

## 不建议使用长事务(持续时间超过60s)
    + 系统里面会存在很老的事务视图，占用大量的存储空间
    + 长事务会占用锁资源，可能会拖垮整个库

## 事务的启动方式

#### 显示启动事务语句
    begin 或者是 start transaction。配套提交的语句是commit，回滚语句是rollback。
#### set autocommit=0
    这个命令会将线程的自动提交关掉，意味着当你只是执行一个select语句的时候，这个事务就启动了，而且并不会自动提交。这个事务会持续到你主动使用commit进行提交，或者是rollback进行回滚，或者是断开连接。
**有的客户端连接框架默认autocommit=0,这就意味着，如果是一个长连接，就会导致接下来的操作都在一个长事务当中。就会意外导致长事务。**

    当set autocommit=1的时候，用begin显示启动的事务，如果执行commit就会主动提交事务。如果执行的是commit work and chain, 则提交事务并且启动下一个事务。这样就节省了再次执行begin的开销。
