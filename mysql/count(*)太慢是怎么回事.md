# count(*)这么慢，我该怎么办


[TOC]
------------------------------------

## count(*)的实现方式(不带where的情况下)
+ MyISAM
    + 把一个表的总行数都存在了磁盘上面，因此执行count(*)的时候会直接返回这个值，效率很高。
+ InnoDB
    + 需要把数据一行一行地从表中读出来，然后累积计数。所以当表中的数据越来越多的时候，计算一个表的总行数还是会越来越慢。

## 为什么InnoDB不和MyISAM一样，将总行数存起来
    由于在MVCC(多版本并发控制)的原因，InnoDB的表应该返回的行数是不确定的。
### example
```mysql
// 假设表中有1000行数据
会话A                       会话B                        会话C
begin                    |                           |
select count(*) from t;  |                           | insert into t(one line)
                         | begin                     | 
                         | insert into t(one line)   |
select count(*) from t;  | select count(*) from t;   | select count(*) from t;
```
    
    之前已经研究过RR级别下的事务隔离了。会话A的两次select结果都是1000。会话B开始之前，会话C还没有commit。会话B是看不到会话C的，
    但是会话B的insert是当前读，所以在自己insert了以后，select读到的是1002。会话C第一个insert是当前读，然后select的时候是快照读，
    能看见自己insert的数据，所以是1001条。
**也就是说，三个会话即使在同一时刻select的时候，结果都是不一样的。所以一定要在自己的一致性视图里面一行一行读，积累数据。**

## InnoDB在count(*)上的优化
    InnoDB的索引组织表，主键索引树的叶子结点是数据。而普通索引的叶子结点上面是主键值。所以说普通的索引树的大小会比主键索引树要小很多。
    而对于count(*)这样的结果，不论是使用哪棵索引树结果都是一样的，MySQL优化器自然会选择比较小的索引树进行搜索。`show table status;`
    里面有一个字段是rows，这个字段表示的是这个表的行数。**但是使用count(*)的时候，不能取这个rows值，因为这个值是估出来的，不准确的。**

## 小结
+ 1. MyISAM表虽然count(*)快，但是不支持事务。
+ 2. show table status; 这条命令很快，但是返回的结果不准确。
+ 3. InnoDB表直接count(*)会扫描全表，虽然结果准确，但是会导致性能问题。
+ 4. 如果你有一个页面需要经常显示交易记录操作总数，只能自己计数了。

------------------------------------------
## 自己计数有哪些实现方式？
### 用缓存系统保存计数
    这个表每被插入一行，Redis中的计数就+1，反之-1。但是缓存系统可能会丢失更新，由于Redis数据不能永久地留在内存里，所以要进行数据
    持久化。但是即使是这样也可能会出现丢失更新的情况，万一在持久化之前，Redis就异常重启了。这时候就直接使用count(*)。

#### 插入数据库在写Redis之前
```mysql
会话A                   会话B
插入一条数据       |
                 |      从Redis中读取数据
                 |      回到数据库中读取数据记录
Redis中的数据+1   |
```

#### 插入数据库在写Redis之后
```mysql
会话A                   会话B
Redis中的数据+1   |
                |       从Redis中读取数据
                |       回到数据库中读取数据记录
插入一条数据      |
```
**在并发系统里面，我们是无法精确控制不同线程的执行时刻的，即使Redisc是正常工作的，这个计数值还是在逻辑上是不准确的**

### 用数据库保存计数
    首先可以解决数据库崩溃数据丢失的问题。而且数据不精确的问题也是可以解决的。利用事务隔离，这样表C中的计数和数据表中
    的数据都是一致的。还是挺厉害的。
```mysql5
会话A                   会话B
begin           |
表C中的计数+1     |
                |      begin
                |      读取表C的计数值
                |      查询最近的100条数据
                |      commit
插入一行数据      |
commit          |
```
### count(*)、count(主键id)、count(字段)、count(1)性能上的区别
    count()是一个聚合函数，一行一行地判断。如果count()的参数是NULL,就不会进行计数。

#### 分析性能原则
+ 1. server层要什么就给什么
+ 2. InnoDB只给必要的值
+ 3. 现在的优化器只优化了count(*)的语义为取行数，其它显而易见的优化并没有做过。

#### count(主键id)
    InnoDB是会遍历整张表的，把每一行的id都取出来，返回给Server层，Server层拿到id以后，判断是不可能为空的，就按行累加。
#### count(1)
    InnoDB是会遍历整张表的，但是不会取值，Server层会对返回的每一行都放一个数字‘1’进去，判断也是不可能为空的，就按行累加。
*单看这两种，count(1)的执行效率会高于count(主键id)。因为count(id)，要解析行拿到主键id，还要进行字段值拷贝*
#### count(字段)
+ 1. 如果这个字段定义为NOT NULL的话，一行行地从记录中读出这个字段，判断不能为NULL，按行累加。
+ 2. 如果这个字段定义为允许NULL的话，那么执行的时候有可能判断为NULL,这样的话还要把值取出来再判断一下，不是NULL的才能累加。
#### count(*)
    并不会把全部的值都取出来，因为专门做了优化的，所以不取值。count(*)肯定不是NULL，所以按行累加。
#### 性能排序
    count(字段) < count(主键id) < count(1) 约等于 count(*) 所以说尽量使用count(*)

### 思考题
    我们将计数放在InnoDB的表中，利用了事务的隔离性来保证数据的一致性。思考一下在是应该先+1，还是先插入数据呢？
#### solution：
    从系统的并发性能考虑应该先insert，然后再update计数表，因为更新计数表会涉及到行锁的竞争，先插入再更新可以最大程度减少事务之间的锁竞争。提升并发度。如果先update的话，事务一旦拿到行锁就要等待到commit了以后才能释放行锁，所以把update放在最后，可以减少其它事务等待的时间，这样并发性能更加好。