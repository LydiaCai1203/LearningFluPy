# 第一讲：一条SQL语句是如何执行的

[TOC]

## MySQL的逻辑架构

![1](https://github.com/LydiaCai1203/leetcode-practice/blob/master/statics/mysql%E9%80%BB%E8%BE%91%E6%9E%B6%E6%9E%84%E5%9B%BE.jpg)

### Server层

#### 连接器
    负责和客户端建立连接、获取权限、维持和管理连接
##### 1. 连接命令
    mysql -h host -P port -u user -p
    -p 后面直接跟着输入密码的话，可能会导致密码泄露，如果连接的是生产服务器，建议不要这么做
##### 2. 连接上以后
    连接器会去权限表里面查出用户拥有的权限。之后这个连接里面的所有判断逻辑全都依赖于此时读到的权限。也就是说，如果一个用户成功建立了连接以后，之后对这个用户的权限所做的修改，也不会影响到已经存在的连接的权限
##### 3. 如果是空闲连接
    wait_timeout = 8 hour；如果连接以后没有动作，且超时，连接器就会将它自动断开
##### 4. 常见的问题

    当全部都使用长连接的时候，有时候发现MySQL的占用内存涨得特别快，这是因为MySQL在执行过程中使用的内存是管理在连接对象里面的。这些资源只有在连接断开的时候才会释放。所以如果长连接长时间积累下来的话，可能会导致内存占用太大。这时候会被系统强制杀掉，现象上看就是MySQL异常重启了。
##### 5. 解决方案
    1. 定期断开长连接。或者是使用一段时间以后，判断如果一个连接里面使用过一个占用内存的大查询以后，就断开连接。
    2. MySQL5.7以后，可以在每次执行过一个比较大的操作以后，通过执行mysql_reset_connection来重新初始化连接。这个过程都不需要重连和验证，只是将连接恢复到刚刚创建好的时候。

#### 查询缓存
    MySQL拿到一个查询请求以后，现在查询缓存看看之前是不是执行过这条语句。之前执行过的查询语句的结果会以key-value的形式存储在内存中。key是查询的语句，value是查询的结果。
##### 1. 利
    如果命中缓存，结果被直接返回，效率很高。
##### 2. 弊
    查询缓存的失效非常频繁，只要有对一个表进行更新，这个表上所有的查询缓存都会被清空。所以对于更新压力大的数据库，查询缓存的命中率非常低。
#### 3. use
```mysql5
// 可以将参数query_cache_type设置为DEMAND，这样对于默认的SQL语句，都不会使用查询缓存
// 不过8.0之后就没有查询缓存这个东西了
select SQL_CACHE * from T where id=10;
```

#### 分析器
    分析器会先对SQL语句进行词法分析，接着按照语法分析规则判断SQL语句是否合法
#### 优化器
+ 当表里面有多个索引的时候，决定使用哪个索引
+ 当有表连接的时候，决定各个表的连接顺序
    + 可以先从t1中找到c=10的值，去和t2进行表连接，再找出t2.d=20的值
    + 可以先从t1中找到c=10的值，去和t2进行表连接，再找出t2.d=20的值
    + 优化器的作用就是选择上面两种的效率更高的方案了
```mysql5
    select * from t1 join t2 using(id) where t1.c=10 and t2.d=20;
```
### 执行器
    + 检查是否对该表有执行查询的权限
        + 命中缓存：会在返回缓存结果之前进行权限检查
        + 未命中缓存：会在优化器之前进行权限验证
    + 打开表，根据表使用的引擎定义，使用这个引擎调用的接口，顺序检索整张表，找出符合条件的数据项
    + 将所有满足条件的行组成记录集然后返回给客户端
    + 在数据库的慢查询日志里面，有一个rows_examined字段，表示这条语句在执行过程中一共扫描了多少行
    
### 存储引擎层
    create table的时候 如果不指定引擎类型 默认使用的是InnoDB. 可以通过使用engine=memory,来指定使用内存引擎创建表。不同的存储引擎的表数据存取方式不同，支持的功能也不同。所有的引擎使用的都是一个Server层
