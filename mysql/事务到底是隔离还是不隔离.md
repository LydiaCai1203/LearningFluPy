# 第八讲： 事务到底是隔离的还是不隔离的

[TOC]
---------------------------------

[这个大兄弟总结的比我好](https://mubu.com/doc/hyPYP01r-G)
[一些疑惑的地方可以看这篇文章](https://liuzhengyang.github.io/2016/09/25/mysqlinnodb/)


## MVCC(Multi-Version Concurrency Control)
  本文只介绍了以乐观并发机制实现下的MVCC
### Session(会话)
  一个会话中可以有多个事务，一个会话相当于是一个数据库连接实例。

### MVCC是为了解决什么问题
  为了解决数据一致性的问题。
+ 锁机制可以控制并发操作。
  + 锁机制又分为读锁和写锁，读锁-读锁之间不需要互斥，但是写锁-读锁和写锁-写锁之间需要互斥。这样已经可以大大提高并发率了。
+ MVCC。
  + MVCC采用了一种在**读数据之前**进行快照的方法。当前事务在运行期间只能看见自己快照内的数据。

### RR中的"快照"
+ 什么时候创建
  + 在第一个查询语句执行的时候开始创建，并不是从start transaction这句开始创建。
      ```mysql
      start transaction;
      select * from t1;
      update t1 set k=k+1;
      select * from t1;
      commit;
      ```
  + 在事务一开始就创建
      ```mysql
      start transaction with consistent snapshot;
      select * from t1;
      update t1 set k=k+1;
      select * from t1;
      commit;
      ```
+ 实现原理
  + transaction id
    + InnoDB里面每个事务都有一个id, 是事务开始的时候像数据库引擎申请创建的。
  + row trx_id
    + 每一行数据都有**多个版本**，每次事务更新的时候，都会把transaction id 赋值给 row trx_id。
  + 图解：
    + ![行状态变更图](../statics/行状态变更图.jpg)
    + U1、U2、U3就是存储在undolog中的逆向操作。
    + ![undolog segment](../statics/undo_segment.jpg)
    + 事务要先判断自己能看到哪个版本的数据，可见的最新的数据作为当前事务的快照。快照是由**当前最新数据版本+undolog中的操作**生成的。
  + 代码级别的实现原理暂时不能理解所以不写了。

+ 判断某事务对当前数据各个版本的可见性
  
        对于一个事务视图来说，自己更新的数据总是可见的。补充说明：下文说的事务开始以后，指的是快照创建完成以后。
  + 对于未提交的数据版本，当前事务是不可见的。
  + 对于已经提交的数据版本，但是是在当前事务开始以后提交的，是不可见的。
  + 对于已经提交的数据版本，但是是在当前事务开始之前提交的，是可见的。


### 问题
![RR级别下的幻读](../statics/RR级别下的幻读.jpg)
#### 一致性读(快照读) 和 当前读
+ 快照读  
  + 在RR级别下，普通的读操作(select)都是不添加锁的，使用的是MVCC一致性读。
+ 当前读
  + ```mysql
    update T set field=value;
    delete from T where field=value;
    insert into T values();
    // 重点注意
    select .... for update;
    select .... lock in share mode;
    ```
  + [官方文档解释以上语句](https://dev.mysql.com/doc/refman/5.7/en/innodb-locks-set.html)
  + 在RR级别下，以上的SQL语句执行之前，使用的都是最新数据版本。就是RC下的效果。
#### 现象
  在事务A中，语句8应该读到的只有两行。但是却读到了当前最新的数据版本。
#### 原因
  因为update语句是当前读，读到的是最新的数据版本。
#### 事务A中的update语句是马上执行的吗？select语句呢？
+ MVCC的出现让 读-写 不互斥了。这里只是普通的读操作，并不包括上文提到的’当前读‘的SQL语句。
+ 如果把语句3换成update语句，那么3在执行的时候会拿到行锁，7在执行的时候 也要拿到行锁才能update。这就涉及到之前所说的两阶段锁释放机制，7要执行，则必须等到事务Bcommit了以后，将行锁释放。然后事务A拿到行锁，得以执行。
