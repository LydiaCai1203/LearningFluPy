# 行锁功过：如何减少行锁对性能的影响？
    MySQL的行锁是在引擎层由各个引擎自己实现的，并不是所有的引擎都支持行锁。MyISAM就不支持去除行锁，不支持行锁也意味着在并发执行的时候只能使用表锁。对于这种引擎的表，同一张表在任何时刻都只能有一个更新在执行。InnoDB是支持行锁的，所以这也是InnoDB能取代MyISAM的一个重要原因。
    
[TOC]
---------------------------------

## 概念
    行锁，针对数据表中行记录的锁。比如事务A更新一行，事务B也要更新这一行，事务B要先等事务A操作完成以后才能操作。

## 从两阶段锁开始说起
![两阶段锁](https://github.com/LydiaCai1203/leetcode-practice/blob/master/statics/%E4%B8%A4%E9%98%B6%E6%AE%B5%E9%94%81.jpg)
    
+ 事务B 要等到 事务A commit以后，才会执行。
+ 事务A持有两个记录的行锁。

### 两阶段锁协议
    行锁是在需要的时候加上，但是并非是不需要了就立即释放。而是要等到事务结束了才会释放。
#### 原则
    如果你的事务中需要锁住多个行，要把可能造成的锁冲突，最可能影响并发度的锁尽量后放。
### 例子
    去电影院购票，购买一张票需要执行三个动作。
+ 1. 从顾客A账户余额中扣除电影票价
+ 2. 给影院B账户余额中增加电影票价
+ 3. 记录一条交易日志

#### 这三条语句应当放在一个事务中。但是怎么安排这三条语句在事务中的顺序呢？
    如果同时有事务A和事务B在进行，两个事务会发生冲突的只有语句2，很明显要更新同一个影院的账户余额。根据两阶段锁协议，事务只有在提交的时候，锁才会被释放，所以如果你把语句2安排在最后，（3，1，2）这样的顺序，那影院账户余额这一行的锁时间就少。最大程度上减少事务并发之间的锁等待。提升了并发度。

------------------------
## 死锁和死锁检测
![死锁和死锁检测](https://github.com/LydiaCai1203/leetcode-practice/blob/master/statics/%E6%AD%BB%E9%94%81%E5%92%8C%E6%AD%BB%E9%94%81%E6%A3%80%E6%B5%8B.jpg)

    影院活动，低价预售一年内所有的电影票，但是活动只进行一天，在活动时间开始的时候，MySQL就挂了，CPU消耗100%，但是数据库每秒执行不到100个事务。
### 死锁：
    资源的循环依赖，涉及的线程都在等待别的线程释放资源的时候，就会导致几个线程进入无限循环等待的情况。
### 解释：
    事务A在等待事务B释放id=2的行锁，事务B在等待事务A释放id=1的行锁，事务A和事务B都在互相等待对方的资源释放。于是进入死锁状态
### 措施：
+ 直接进入等待，直到超时。这个超时时间可以通过设置innode_lock_wait_timeout来设置。
    + 这个值不能设的太小，如果只是普通的锁等待，会出现误伤。
    + 这个值不能设的太大，如果是在线服务的话，这个值是不能容忍的。

+ 发起死锁检测
    发现死锁以后，主动回滚死锁链条中的某一个事务，让其它的事务得以继续执行。将innodb_deadlock_detect设置为on。将自动进行死锁检测。
    + 额外负担：
        死锁检测这个过程。每个新来的被堵住的线程，都要判断一下是不是因为自己的到来导致死锁，这是一个时间复杂度为O(N)的操作。假设有1000个并发线程要同时更新一行，那么死锁检测操作就是100万这个量级的。这回消耗大量的CPU资源。

### 怎么解决由这种热点行更新导致的性能问题呢？
+ 如果你能确保这个业务一定不会出现死锁问题，可以临时把死锁检测关闭
+ 控制并发度
    + 比如控制同一行一个时刻最多只有是个线程可以进行更新操作。死锁检测成本就很低。
    + 不要在客户端控制并发数，即使每个客户端控制在5个线程所有，汇集到服务端以后的峰值可能达到3000左右。
    + **对于相同行的更新，在进入引擎之前排队，这样在InnoDB内部就不会有大量的死锁检测工作了。**
    + **可以通过将一行改成逻辑上的多行，比如影院账户，可以分散在十个账户上，账户余额等于十条记录之和。这样每次冲突的概率变成原来的1/10，可以减少锁等待个数，减少了死锁等待的CPU消耗。**

------------------------
## 小结
+ 1. 如果事务中需要锁住多个行，把最有可能发生锁冲突的行往后排。
+ 2. 解决死锁的三种方案：
    + 设置锁等待时间
    + 进行死锁检测
    + 从服务端控制并发度

------------------------
## 思考题
    如果要删除一个表中的前10000行数据
+ delete from T limit 10000;
+ 在一个连接中循环执行20次，delete from T limit 500;
+ 在20个连接中同时执行 delete from T limit 500;

