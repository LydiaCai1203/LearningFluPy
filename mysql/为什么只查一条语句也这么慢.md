# 为什么只查一行的语句也执行地这么慢
    如果MySQL本身就有很大的压力，导致数据库服务器CPU占用率很高，或者是IO占用率很高的话，这种情况下所有的语句执行都会很慢。

[TOC]
-------------------------------------
```mysql
mysql> CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;

delimiter ;;
create procedure idata()
begin
  declare i int;
  set i=1;
  while(i<=100000) do
    insert into t values(i,i);
    set i=i+1;
  end while;
end;;
delimiter ;

call idata();
```

## 第一类：查询长时间不返回

### 情况一: 等MDL锁
```mysql
mysql> select * from t where id=1;
```
#### 可能原因
    `show processlist` 使用这条命令看一下当前的select语句处于什么状态
![](../statics/show_processlist.png)
+ 1. 等MDL锁
    + a. 表示现在有一个线程正在表t上请求或者是已经持有MDL锁，结果把select给堵住了。
    + 处理方式
        + a. 找到持有MDL锁的人然后kill掉。
        + b. 使用`select blocking_pid from sys.schema_table_lock_waits;`就可以找到当前阻塞的进程id了，使用kill命令断开即可。

### 情况二: 等Flush
```mysql
mysql> select * from information_schema.processlist where id=1;
```
#### 可能原因
![](../statics/wait_flush.png)
+ 1. 等Flush
    + a. 表示现在有一个线程正要对表t进行Flush操作。
        + a. `flush tables t with read lock;` 和 `flush tables with read lock;` 第二条语句的意思就是关闭所有打开的表。
    + 处理方式
        + a. 找到flush那条语句所在的session 然后kill掉即可。

### 情况三: 等行锁
```mysql
mysql> select * from t where id=1 lock in share mode; 
```
+ 1. 等行锁
    + a. 