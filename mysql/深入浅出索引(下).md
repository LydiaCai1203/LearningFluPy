# 深入浅出索引(下)

[TOC]
    提高数据查询的效率。

-----------------------------------
## 问题

### 查询语句
```mysql5
select * from T where k between 3 and 5;
```
#### 表结构
```mysql5
create table T(
    ID int primary key,
    k int not null default 0, 
    s varchar(16) not null default '',
    index k(k)
)engine=InnoDB;

insert into T values(
    100, 1, 'a',
    200, 2, 'b',
    300, 3, 'c',
    500, 5, 'd',
    600, 6, 'e',)
```
![索引树结构图](https://github.com/LydiaCai1203/leetcode-practice/blob/master/statics/Innodb%E7%B4%A2%E5%BC%95%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.jpg)
#### 索引查询的执行流程
+ 1. 在k的索引树上找到k=3的记录，取得ID=300；
+ 2. 去ID索引树上找到ID=300对应的R3(那一行数据)；
+ 3. 在k的索引树上找到k=5的记录，取得ID=500;
+ 4. 在ID索引树上找到ID=500对应的R4(那一行数据);
+ 5. 在k的索引树上取下k=6的记录，不满足条件，则循环结束；


### 覆盖索引(经过索引优化，避免回表)
#### 查询语句
    在这个索引中，索引k已经覆盖了我们的查询需求，称为覆盖索引。(二级索引里面放的是主键的值)
```mysql5
select ID from T where k between 3 and 5;
```
#### 覆盖索引可以减少树的搜索次数，显著提高查询性能，所以使用覆盖索引是一个常见的性能优化手段。

#### 在引擎内部使用覆盖索引在索引k上其实读取了3个数据，但是对于MySQL的Server层来说，引擎只拿到了两条数据，所以MySQL认为扫描行数是2.

#### 适当使用联合索引可以避免回表的出现，但是会有建立冗余索引的情况出现，权衡处理。

-----------------------------------
### 最左前缀原则
![name_age联合索引示意图]()
```mysql5
create table tuser (
    id int(11) not null,
    id_card varchar(12) default null,
    name varchar(32) default null,
    age int(11) default null,
    ismale tinyint(1) default null,
    primary key(id),
    key id_card(id_card),
    key name_age(name, age)
)engine=InnoDB;
```

